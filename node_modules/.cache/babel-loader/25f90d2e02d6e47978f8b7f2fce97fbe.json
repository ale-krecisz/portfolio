{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _ObjectRenderer2 = require('../../renderers/webgl/utils/ObjectRenderer');\n\nvar _ObjectRenderer3 = _interopRequireDefault(_ObjectRenderer2);\n\nvar _WebGLRenderer = require('../../renderers/webgl/WebGLRenderer');\n\nvar _WebGLRenderer2 = _interopRequireDefault(_WebGLRenderer);\n\nvar _createIndicesForQuads = require('../../utils/createIndicesForQuads');\n\nvar _createIndicesForQuads2 = _interopRequireDefault(_createIndicesForQuads);\n\nvar _generateMultiTextureShader = require('./generateMultiTextureShader');\n\nvar _generateMultiTextureShader2 = _interopRequireDefault(_generateMultiTextureShader);\n\nvar _checkMaxIfStatmentsInShader = require('../../renderers/webgl/utils/checkMaxIfStatmentsInShader');\n\nvar _checkMaxIfStatmentsInShader2 = _interopRequireDefault(_checkMaxIfStatmentsInShader);\n\nvar _BatchBuffer = require('./BatchBuffer');\n\nvar _BatchBuffer2 = _interopRequireDefault(_BatchBuffer);\n\nvar _settings = require('../../settings');\n\nvar _settings2 = _interopRequireDefault(_settings);\n\nvar _utils = require('../../utils');\n\nvar _pixiGlCore = require('pixi-gl-core');\n\nvar _pixiGlCore2 = _interopRequireDefault(_pixiGlCore);\n\nvar _bitTwiddle = require('bit-twiddle');\n\nvar _bitTwiddle2 = _interopRequireDefault(_bitTwiddle);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar TICK = 0;\nvar TEXTURE_TICK = 0;\n/**\n * Renderer dedicated to drawing and batching sprites.\n *\n * @class\n * @private\n * @memberof PIXI\n * @extends PIXI.ObjectRenderer\n */\n\nvar SpriteRenderer = function (_ObjectRenderer) {\n  _inherits(SpriteRenderer, _ObjectRenderer);\n  /**\n   * @param {PIXI.WebGLRenderer} renderer - The renderer this sprite batch works for.\n   */\n\n\n  function SpriteRenderer(renderer) {\n    _classCallCheck(this, SpriteRenderer);\n    /**\n     * Number of values sent in the vertex buffer.\n     * aVertexPosition(2), aTextureCoord(1), aColor(1), aTextureId(1) = 5\n     *\n     * @member {number}\n     */\n\n\n    var _this = _possibleConstructorReturn(this, _ObjectRenderer.call(this, renderer));\n\n    _this.vertSize = 5;\n    /**\n     * The size of the vertex information in bytes.\n     *\n     * @member {number}\n     */\n\n    _this.vertByteSize = _this.vertSize * 4;\n    /**\n     * The number of images in the SpriteRenderer before it flushes.\n     *\n     * @member {number}\n     */\n\n    _this.size = _settings2.default.SPRITE_BATCH_SIZE; // 2000 is a nice balance between mobile / desktop\n    // the total number of bytes in our batch\n    // let numVerts = this.size * 4 * this.vertByteSize;\n\n    _this.buffers = [];\n\n    for (var i = 1; i <= _bitTwiddle2.default.nextPow2(_this.size); i *= 2) {\n      _this.buffers.push(new _BatchBuffer2.default(i * 4 * _this.vertByteSize));\n    }\n    /**\n     * Holds the indices of the geometry (quads) to draw\n     *\n     * @member {Uint16Array}\n     */\n\n\n    _this.indices = (0, _createIndicesForQuads2.default)(_this.size);\n    /**\n     * The default shaders that is used if a sprite doesn't have a more specific one.\n     * there is a shader for each number of textures that can be rendererd.\n     * These shaders will also be generated on the fly as required.\n     * @member {PIXI.Shader[]}\n     */\n\n    _this.shader = null;\n    _this.currentIndex = 0;\n    _this.groups = [];\n\n    for (var k = 0; k < _this.size; k++) {\n      _this.groups[k] = {\n        textures: [],\n        textureCount: 0,\n        ids: [],\n        size: 0,\n        start: 0,\n        blend: 0\n      };\n    }\n\n    _this.sprites = [];\n    _this.vertexBuffers = [];\n    _this.vaos = [];\n    _this.vaoMax = 2;\n    _this.vertexCount = 0;\n\n    _this.renderer.on('prerender', _this.onPrerender, _this);\n\n    return _this;\n  }\n  /**\n   * Sets up the renderer context and necessary buffers.\n   *\n   * @private\n   */\n\n\n  SpriteRenderer.prototype.onContextChange = function onContextChange() {\n    var gl = this.renderer.gl;\n\n    if (this.renderer.legacy) {\n      this.MAX_TEXTURES = 1;\n    } else {\n      // step 1: first check max textures the GPU can handle.\n      this.MAX_TEXTURES = Math.min(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), _settings2.default.SPRITE_MAX_TEXTURES); // step 2: check the maximum number of if statements the shader can have too..\n\n      this.MAX_TEXTURES = (0, _checkMaxIfStatmentsInShader2.default)(this.MAX_TEXTURES, gl);\n    }\n\n    this.shader = (0, _generateMultiTextureShader2.default)(gl, this.MAX_TEXTURES); // create a couple of buffers\n\n    this.indexBuffer = _pixiGlCore2.default.GLBuffer.createIndexBuffer(gl, this.indices, gl.STATIC_DRAW); // we use the second shader as the first one depending on your browser may omit aTextureId\n    // as it is not used by the shader so is optimized out.\n\n    this.renderer.bindVao(null);\n    var attrs = this.shader.attributes;\n\n    for (var i = 0; i < this.vaoMax; i++) {\n      /* eslint-disable max-len */\n      var vertexBuffer = this.vertexBuffers[i] = _pixiGlCore2.default.GLBuffer.createVertexBuffer(gl, null, gl.STREAM_DRAW);\n      /* eslint-enable max-len */\n      // build the vao object that will render..\n\n\n      var vao = this.renderer.createVao().addIndex(this.indexBuffer).addAttribute(vertexBuffer, attrs.aVertexPosition, gl.FLOAT, false, this.vertByteSize, 0).addAttribute(vertexBuffer, attrs.aTextureCoord, gl.UNSIGNED_SHORT, true, this.vertByteSize, 2 * 4).addAttribute(vertexBuffer, attrs.aColor, gl.UNSIGNED_BYTE, true, this.vertByteSize, 3 * 4);\n\n      if (attrs.aTextureId) {\n        vao.addAttribute(vertexBuffer, attrs.aTextureId, gl.FLOAT, false, this.vertByteSize, 4 * 4);\n      }\n\n      this.vaos[i] = vao;\n    }\n\n    this.vao = this.vaos[0];\n    this.currentBlendMode = 99999;\n    this.boundTextures = new Array(this.MAX_TEXTURES);\n  };\n  /**\n   * Called before the renderer starts rendering.\n   *\n   */\n\n\n  SpriteRenderer.prototype.onPrerender = function onPrerender() {\n    this.vertexCount = 0;\n  };\n  /**\n   * Renders the sprite object.\n   *\n   * @param {PIXI.Sprite} sprite - the sprite to render when using this spritebatch\n   */\n\n\n  SpriteRenderer.prototype.render = function render(sprite) {\n    // TODO set blend modes..\n    // check texture..\n    if (this.currentIndex >= this.size) {\n      this.flush();\n    } // get the uvs for the texture\n    // if the uvs have not updated then no point rendering just yet!\n\n\n    if (!sprite._texture._uvs) {\n      return;\n    } // push a texture.\n    // increment the batchsize\n\n\n    this.sprites[this.currentIndex++] = sprite;\n  };\n  /**\n   * Renders the content and empties the current batch.\n   *\n   */\n\n\n  SpriteRenderer.prototype.flush = function flush() {\n    if (this.currentIndex === 0) {\n      return;\n    }\n\n    var gl = this.renderer.gl;\n    var MAX_TEXTURES = this.MAX_TEXTURES;\n\n    var np2 = _bitTwiddle2.default.nextPow2(this.currentIndex);\n\n    var log2 = _bitTwiddle2.default.log2(np2);\n\n    var buffer = this.buffers[log2];\n    var sprites = this.sprites;\n    var groups = this.groups;\n    var float32View = buffer.float32View;\n    var uint32View = buffer.uint32View;\n    var boundTextures = this.boundTextures;\n    var rendererBoundTextures = this.renderer.boundTextures;\n    var touch = this.renderer.textureGC.count;\n    var index = 0;\n    var nextTexture = void 0;\n    var currentTexture = void 0;\n    var groupCount = 1;\n    var textureCount = 0;\n    var currentGroup = groups[0];\n    var vertexData = void 0;\n    var uvs = void 0;\n    var blendMode = _utils.premultiplyBlendMode[sprites[0]._texture.baseTexture.premultipliedAlpha ? 1 : 0][sprites[0].blendMode];\n    currentGroup.textureCount = 0;\n    currentGroup.start = 0;\n    currentGroup.blend = blendMode;\n    TICK++;\n    var i = void 0; // copy textures..\n\n    for (i = 0; i < MAX_TEXTURES; ++i) {\n      var bt = rendererBoundTextures[i];\n\n      if (bt._enabled === TICK) {\n        boundTextures[i] = this.renderer.emptyTextures[i];\n        continue;\n      }\n\n      boundTextures[i] = bt;\n      bt._virtalBoundId = i;\n      bt._enabled = TICK;\n    }\n\n    TICK++;\n\n    for (i = 0; i < this.currentIndex; ++i) {\n      // upload the sprite elemetns...\n      // they have all ready been calculated so we just need to push them into the buffer.\n      var sprite = sprites[i];\n      sprites[i] = null;\n      nextTexture = sprite._texture.baseTexture;\n\n      var spriteBlendMode = _utils.premultiplyBlendMode[Number(nextTexture.premultipliedAlpha)][sprite.blendMode];\n\n      if (blendMode !== spriteBlendMode) {\n        // finish a group..\n        blendMode = spriteBlendMode; // force the batch to break!\n\n        currentTexture = null;\n        textureCount = MAX_TEXTURES;\n        TICK++;\n      }\n\n      if (currentTexture !== nextTexture) {\n        currentTexture = nextTexture;\n\n        if (nextTexture._enabled !== TICK) {\n          if (textureCount === MAX_TEXTURES) {\n            TICK++;\n            currentGroup.size = i - currentGroup.start;\n            textureCount = 0;\n            currentGroup = groups[groupCount++];\n            currentGroup.blend = blendMode;\n            currentGroup.textureCount = 0;\n            currentGroup.start = i;\n          }\n\n          nextTexture.touched = touch;\n\n          if (nextTexture._virtalBoundId === -1) {\n            for (var j = 0; j < MAX_TEXTURES; ++j) {\n              var tIndex = (j + TEXTURE_TICK) % MAX_TEXTURES;\n              var t = boundTextures[tIndex];\n\n              if (t._enabled !== TICK) {\n                TEXTURE_TICK++;\n                t._virtalBoundId = -1;\n                nextTexture._virtalBoundId = tIndex;\n                boundTextures[tIndex] = nextTexture;\n                break;\n              }\n            }\n          }\n\n          nextTexture._enabled = TICK;\n          currentGroup.textureCount++;\n          currentGroup.ids[textureCount] = nextTexture._virtalBoundId;\n          currentGroup.textures[textureCount++] = nextTexture;\n        }\n      }\n\n      vertexData = sprite.vertexData; // TODO this sum does not need to be set each frame..\n\n      uvs = sprite._texture._uvs.uvsUint32;\n\n      if (this.renderer.roundPixels) {\n        var resolution = this.renderer.resolution; // xy\n\n        float32View[index] = (vertexData[0] * resolution | 0) / resolution;\n        float32View[index + 1] = (vertexData[1] * resolution | 0) / resolution; // xy\n\n        float32View[index + 5] = (vertexData[2] * resolution | 0) / resolution;\n        float32View[index + 6] = (vertexData[3] * resolution | 0) / resolution; // xy\n\n        float32View[index + 10] = (vertexData[4] * resolution | 0) / resolution;\n        float32View[index + 11] = (vertexData[5] * resolution | 0) / resolution; // xy\n\n        float32View[index + 15] = (vertexData[6] * resolution | 0) / resolution;\n        float32View[index + 16] = (vertexData[7] * resolution | 0) / resolution;\n      } else {\n        // xy\n        float32View[index] = vertexData[0];\n        float32View[index + 1] = vertexData[1]; // xy\n\n        float32View[index + 5] = vertexData[2];\n        float32View[index + 6] = vertexData[3]; // xy\n\n        float32View[index + 10] = vertexData[4];\n        float32View[index + 11] = vertexData[5]; // xy\n\n        float32View[index + 15] = vertexData[6];\n        float32View[index + 16] = vertexData[7];\n      }\n\n      uint32View[index + 2] = uvs[0];\n      uint32View[index + 7] = uvs[1];\n      uint32View[index + 12] = uvs[2];\n      uint32View[index + 17] = uvs[3];\n      /* eslint-disable max-len */\n\n      var alpha = Math.min(sprite.worldAlpha, 1.0); // we dont call extra function if alpha is 1.0, that's faster\n\n      var argb = alpha < 1.0 && nextTexture.premultipliedAlpha ? (0, _utils.premultiplyTint)(sprite._tintRGB, alpha) : sprite._tintRGB + (alpha * 255 << 24);\n      uint32View[index + 3] = uint32View[index + 8] = uint32View[index + 13] = uint32View[index + 18] = argb;\n      float32View[index + 4] = float32View[index + 9] = float32View[index + 14] = float32View[index + 19] = nextTexture._virtalBoundId;\n      /* eslint-enable max-len */\n\n      index += 20;\n    }\n\n    currentGroup.size = i - currentGroup.start;\n\n    if (!_settings2.default.CAN_UPLOAD_SAME_BUFFER) {\n      // this is still needed for IOS performance..\n      // it really does not like uploading to the same buffer in a single frame!\n      if (this.vaoMax <= this.vertexCount) {\n        this.vaoMax++;\n        var attrs = this.shader.attributes;\n        /* eslint-disable max-len */\n\n        var vertexBuffer = this.vertexBuffers[this.vertexCount] = _pixiGlCore2.default.GLBuffer.createVertexBuffer(gl, null, gl.STREAM_DRAW);\n        /* eslint-enable max-len */\n        // build the vao object that will render..\n\n\n        var vao = this.renderer.createVao().addIndex(this.indexBuffer).addAttribute(vertexBuffer, attrs.aVertexPosition, gl.FLOAT, false, this.vertByteSize, 0).addAttribute(vertexBuffer, attrs.aTextureCoord, gl.UNSIGNED_SHORT, true, this.vertByteSize, 2 * 4).addAttribute(vertexBuffer, attrs.aColor, gl.UNSIGNED_BYTE, true, this.vertByteSize, 3 * 4);\n\n        if (attrs.aTextureId) {\n          vao.addAttribute(vertexBuffer, attrs.aTextureId, gl.FLOAT, false, this.vertByteSize, 4 * 4);\n        }\n\n        this.vaos[this.vertexCount] = vao;\n      }\n\n      this.renderer.bindVao(this.vaos[this.vertexCount]);\n      this.vertexBuffers[this.vertexCount].upload(buffer.vertices, 0, false);\n      this.vertexCount++;\n    } else {\n      // lets use the faster option, always use buffer number 0\n      this.vertexBuffers[this.vertexCount].upload(buffer.vertices, 0, true);\n    }\n\n    for (i = 0; i < MAX_TEXTURES; ++i) {\n      rendererBoundTextures[i]._virtalBoundId = -1;\n    } // render the groups..\n\n\n    for (i = 0; i < groupCount; ++i) {\n      var group = groups[i];\n      var groupTextureCount = group.textureCount;\n\n      for (var _j = 0; _j < groupTextureCount; _j++) {\n        currentTexture = group.textures[_j]; // reset virtual ids..\n        // lets do a quick check..\n\n        if (rendererBoundTextures[group.ids[_j]] !== currentTexture) {\n          this.renderer.bindTexture(currentTexture, group.ids[_j], true);\n        } // reset the virtualId..\n\n\n        currentTexture._virtalBoundId = -1;\n      } // set the blend mode..\n\n\n      this.renderer.state.setBlendMode(group.blend);\n      gl.drawElements(gl.TRIANGLES, group.size * 6, gl.UNSIGNED_SHORT, group.start * 6 * 2);\n    } // reset elements for the next flush\n\n\n    this.currentIndex = 0;\n  };\n  /**\n   * Starts a new sprite batch.\n   */\n\n\n  SpriteRenderer.prototype.start = function start() {\n    this.renderer.bindShader(this.shader);\n\n    if (_settings2.default.CAN_UPLOAD_SAME_BUFFER) {\n      // bind buffer #0, we don't need others\n      this.renderer.bindVao(this.vaos[this.vertexCount]);\n      this.vertexBuffers[this.vertexCount].bind();\n    }\n  };\n  /**\n   * Stops and flushes the current batch.\n   *\n   */\n\n\n  SpriteRenderer.prototype.stop = function stop() {\n    this.flush();\n  };\n  /**\n   * Destroys the SpriteRenderer.\n   *\n   */\n\n\n  SpriteRenderer.prototype.destroy = function destroy() {\n    for (var i = 0; i < this.vaoMax; i++) {\n      if (this.vertexBuffers[i]) {\n        this.vertexBuffers[i].destroy();\n      }\n\n      if (this.vaos[i]) {\n        this.vaos[i].destroy();\n      }\n    }\n\n    if (this.indexBuffer) {\n      this.indexBuffer.destroy();\n    }\n\n    this.renderer.off('prerender', this.onPrerender, this);\n\n    _ObjectRenderer.prototype.destroy.call(this);\n\n    if (this.shader) {\n      this.shader.destroy();\n      this.shader = null;\n    }\n\n    this.vertexBuffers = null;\n    this.vaos = null;\n    this.indexBuffer = null;\n    this.indices = null;\n    this.sprites = null;\n\n    for (var _i = 0; _i < this.buffers.length; ++_i) {\n      this.buffers[_i].destroy();\n    }\n  };\n\n  return SpriteRenderer;\n}(_ObjectRenderer3.default);\n\nexports.default = SpriteRenderer;\n\n_WebGLRenderer2.default.registerPlugin('sprite', SpriteRenderer);","map":null,"metadata":{},"sourceType":"script"}