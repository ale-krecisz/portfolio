{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _const = require('../../const');\n\nvar _settings = require('../../settings');\n\nvar _settings2 = _interopRequireDefault(_settings);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n/**\n * TextureGarbageCollector. This class manages the GPU and ensures that it does not get clogged\n * up with textures that are no longer being used.\n *\n * @class\n * @memberof PIXI\n */\n\n\nvar TextureGarbageCollector = function () {\n  /**\n   * @param {PIXI.WebGLRenderer} renderer - The renderer this manager works for.\n   */\n  function TextureGarbageCollector(renderer) {\n    _classCallCheck(this, TextureGarbageCollector);\n\n    this.renderer = renderer;\n    this.count = 0;\n    this.checkCount = 0;\n    this.maxIdle = _settings2.default.GC_MAX_IDLE;\n    this.checkCountMax = _settings2.default.GC_MAX_CHECK_COUNT;\n    this.mode = _settings2.default.GC_MODE;\n  }\n  /**\n   * Checks to see when the last time a texture was used\n   * if the texture has not been used for a specified amount of time it will be removed from the GPU\n   */\n\n\n  TextureGarbageCollector.prototype.update = function update() {\n    this.count++;\n\n    if (this.mode === _const.GC_MODES.MANUAL) {\n      return;\n    }\n\n    this.checkCount++;\n\n    if (this.checkCount > this.checkCountMax) {\n      this.checkCount = 0;\n      this.run();\n    }\n  };\n  /**\n   * Checks to see when the last time a texture was used\n   * if the texture has not been used for a specified amount of time it will be removed from the GPU\n   */\n\n\n  TextureGarbageCollector.prototype.run = function run() {\n    var tm = this.renderer.textureManager;\n    var managedTextures = tm._managedTextures;\n    var wasRemoved = false;\n\n    for (var i = 0; i < managedTextures.length; i++) {\n      var texture = managedTextures[i]; // only supports non generated textures at the moment!\n\n      if (!texture._glRenderTargets && this.count - texture.touched > this.maxIdle) {\n        tm.destroyTexture(texture, true);\n        managedTextures[i] = null;\n        wasRemoved = true;\n      }\n    }\n\n    if (wasRemoved) {\n      var j = 0;\n\n      for (var _i = 0; _i < managedTextures.length; _i++) {\n        if (managedTextures[_i] !== null) {\n          managedTextures[j++] = managedTextures[_i];\n        }\n      }\n\n      managedTextures.length = j;\n    }\n  };\n  /**\n   * Removes all the textures within the specified displayObject and its children from the GPU\n   *\n   * @param {PIXI.DisplayObject} displayObject - the displayObject to remove the textures from.\n   */\n\n\n  TextureGarbageCollector.prototype.unload = function unload(displayObject) {\n    var tm = this.renderer.textureManager; // only destroy non generated textures\n\n    if (displayObject._texture && displayObject._texture._glRenderTargets) {\n      tm.destroyTexture(displayObject._texture, true);\n    }\n\n    for (var i = displayObject.children.length - 1; i >= 0; i--) {\n      this.unload(displayObject.children[i]);\n    }\n  };\n\n  return TextureGarbageCollector;\n}();\n\nexports.default = TextureGarbageCollector;","map":null,"metadata":{},"sourceType":"script"}