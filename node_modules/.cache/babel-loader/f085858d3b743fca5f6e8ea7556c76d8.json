{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _SystemRenderer2 = require('../SystemRenderer');\n\nvar _SystemRenderer3 = _interopRequireDefault(_SystemRenderer2);\n\nvar _CanvasMaskManager = require('./utils/CanvasMaskManager');\n\nvar _CanvasMaskManager2 = _interopRequireDefault(_CanvasMaskManager);\n\nvar _CanvasRenderTarget = require('./utils/CanvasRenderTarget');\n\nvar _CanvasRenderTarget2 = _interopRequireDefault(_CanvasRenderTarget);\n\nvar _mapCanvasBlendModesToPixi = require('./utils/mapCanvasBlendModesToPixi');\n\nvar _mapCanvasBlendModesToPixi2 = _interopRequireDefault(_mapCanvasBlendModesToPixi);\n\nvar _utils = require('../../utils');\n\nvar _const = require('../../const');\n\nvar _settings = require('../../settings');\n\nvar _settings2 = _interopRequireDefault(_settings);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n/**\n * The CanvasRenderer draws the scene and all its content onto a 2d canvas. This renderer should\n * be used for browsers that do not support WebGL. Don't forget to add the CanvasRenderer.view to\n * your DOM or you will not see anything :)\n *\n * @class\n * @memberof PIXI\n * @extends PIXI.SystemRenderer\n */\n\n\nvar CanvasRenderer = function (_SystemRenderer) {\n  _inherits(CanvasRenderer, _SystemRenderer); // eslint-disable-next-line valid-jsdoc\n\n  /**\n   * @param {object} [options] - The optional renderer parameters\n   * @param {number} [options.width=800] - the width of the screen\n   * @param {number} [options.height=600] - the height of the screen\n   * @param {HTMLCanvasElement} [options.view] - the canvas to use as a view, optional\n   * @param {boolean} [options.transparent=false] - If the render view is transparent, default false\n   * @param {boolean} [options.autoResize=false] - If the render view is automatically resized, default false\n   * @param {boolean} [options.antialias=false] - sets antialias (only applicable in chrome at the moment)\n   * @param {number} [options.resolution=1] - The resolution / device pixel ratio of the renderer. The\n   *  resolution of the renderer retina would be 2.\n   * @param {boolean} [options.preserveDrawingBuffer=false] - enables drawing buffer preservation,\n   *  enable this if you need to call toDataUrl on the webgl context.\n   * @param {boolean} [options.clearBeforeRender=true] - This sets if the renderer will clear the canvas or\n   *      not before the new render pass.\n   * @param {number} [options.backgroundColor=0x000000] - The background color of the rendered area\n   *  (shown if not transparent).\n   * @param {boolean} [options.roundPixels=false] - If true PixiJS will Math.floor() x/y values when rendering,\n   *  stopping pixel interpolation.\n   */\n\n\n  function CanvasRenderer(options, arg2, arg3) {\n    _classCallCheck(this, CanvasRenderer);\n\n    var _this = _possibleConstructorReturn(this, _SystemRenderer.call(this, 'Canvas', options, arg2, arg3));\n\n    _this.type = _const.RENDERER_TYPE.CANVAS;\n    /**\n     * The root canvas 2d context that everything is drawn with.\n     *\n     * @member {CanvasRenderingContext2D}\n     */\n\n    _this.rootContext = _this.view.getContext('2d', {\n      alpha: _this.transparent\n    });\n    /**\n     * The currently active canvas 2d context (could change with renderTextures)\n     *\n     * @member {CanvasRenderingContext2D}\n     */\n\n    _this.context = _this.rootContext;\n    /**\n     * Boolean flag controlling canvas refresh.\n     *\n     * @member {boolean}\n     */\n\n    _this.refresh = true;\n    /**\n     * Instance of a CanvasMaskManager, handles masking when using the canvas renderer.\n     *\n     * @member {PIXI.CanvasMaskManager}\n     */\n\n    _this.maskManager = new _CanvasMaskManager2.default(_this);\n    /**\n     * The canvas property used to set the canvas smoothing property.\n     *\n     * @member {string}\n     */\n\n    _this.smoothProperty = 'imageSmoothingEnabled';\n\n    if (!_this.rootContext.imageSmoothingEnabled) {\n      if (_this.rootContext.webkitImageSmoothingEnabled) {\n        _this.smoothProperty = 'webkitImageSmoothingEnabled';\n      } else if (_this.rootContext.mozImageSmoothingEnabled) {\n        _this.smoothProperty = 'mozImageSmoothingEnabled';\n      } else if (_this.rootContext.oImageSmoothingEnabled) {\n        _this.smoothProperty = 'oImageSmoothingEnabled';\n      } else if (_this.rootContext.msImageSmoothingEnabled) {\n        _this.smoothProperty = 'msImageSmoothingEnabled';\n      }\n    }\n\n    _this.initPlugins();\n\n    _this.blendModes = (0, _mapCanvasBlendModesToPixi2.default)();\n    _this._activeBlendMode = null;\n    _this.renderingToScreen = false;\n\n    _this.resize(_this.options.width, _this.options.height);\n    /**\n     * Fired after rendering finishes.\n     *\n     * @event PIXI.CanvasRenderer#postrender\n     */\n\n    /**\n     * Fired before rendering starts.\n     *\n     * @event PIXI.CanvasRenderer#prerender\n     */\n\n\n    return _this;\n  }\n  /**\n   * Renders the object to this canvas view\n   *\n   * @param {PIXI.DisplayObject} displayObject - The object to be rendered\n   * @param {PIXI.RenderTexture} [renderTexture] - A render texture to be rendered to.\n   *  If unset, it will render to the root context.\n   * @param {boolean} [clear=false] - Whether to clear the canvas before drawing\n   * @param {PIXI.Matrix} [transform] - A transformation to be applied\n   * @param {boolean} [skipUpdateTransform=false] - Whether to skip the update transform\n   */\n\n\n  CanvasRenderer.prototype.render = function render(displayObject, renderTexture, clear, transform, skipUpdateTransform) {\n    if (!this.view) {\n      return;\n    } // can be handy to know!\n\n\n    this.renderingToScreen = !renderTexture;\n    this.emit('prerender');\n    var rootResolution = this.resolution;\n\n    if (renderTexture) {\n      renderTexture = renderTexture.baseTexture || renderTexture;\n\n      if (!renderTexture._canvasRenderTarget) {\n        renderTexture._canvasRenderTarget = new _CanvasRenderTarget2.default(renderTexture.width, renderTexture.height, renderTexture.resolution);\n        renderTexture.source = renderTexture._canvasRenderTarget.canvas;\n        renderTexture.valid = true;\n      }\n\n      this.context = renderTexture._canvasRenderTarget.context;\n      this.resolution = renderTexture._canvasRenderTarget.resolution;\n    } else {\n      this.context = this.rootContext;\n    }\n\n    var context = this.context;\n\n    if (!renderTexture) {\n      this._lastObjectRendered = displayObject;\n    }\n\n    if (!skipUpdateTransform) {\n      // update the scene graph\n      var cacheParent = displayObject.parent;\n      var tempWt = this._tempDisplayObjectParent.transform.worldTransform;\n\n      if (transform) {\n        transform.copy(tempWt); // lets not forget to flag the parent transform as dirty...\n\n        this._tempDisplayObjectParent.transform._worldID = -1;\n      } else {\n        tempWt.identity();\n      }\n\n      displayObject.parent = this._tempDisplayObjectParent;\n      displayObject.updateTransform();\n      displayObject.parent = cacheParent; // displayObject.hitArea = //TODO add a temp hit area\n    }\n\n    context.save();\n    context.setTransform(1, 0, 0, 1, 0, 0);\n    context.globalAlpha = 1;\n    this._activeBlendMode = _const.BLEND_MODES.NORMAL;\n    context.globalCompositeOperation = this.blendModes[_const.BLEND_MODES.NORMAL];\n\n    if (navigator.isCocoonJS && this.view.screencanvas) {\n      context.fillStyle = 'black';\n      context.clear();\n    }\n\n    if (clear !== undefined ? clear : this.clearBeforeRender) {\n      if (this.renderingToScreen) {\n        if (this.transparent) {\n          context.clearRect(0, 0, this.width, this.height);\n        } else {\n          context.fillStyle = this._backgroundColorString;\n          context.fillRect(0, 0, this.width, this.height);\n        }\n      } // else {\n      // TODO: implement background for CanvasRenderTarget or RenderTexture?\n      // }\n\n    } // TODO RENDER TARGET STUFF HERE..\n\n\n    var tempContext = this.context;\n    this.context = context;\n    displayObject.renderCanvas(this);\n    this.context = tempContext;\n    context.restore();\n    this.resolution = rootResolution;\n    this.emit('postrender');\n  };\n  /**\n   * Clear the canvas of renderer.\n   *\n   * @param {string} [clearColor] - Clear the canvas with this color, except the canvas is transparent.\n   */\n\n\n  CanvasRenderer.prototype.clear = function clear(clearColor) {\n    var context = this.context;\n    clearColor = clearColor || this._backgroundColorString;\n\n    if (!this.transparent && clearColor) {\n      context.fillStyle = clearColor;\n      context.fillRect(0, 0, this.width, this.height);\n    } else {\n      context.clearRect(0, 0, this.width, this.height);\n    }\n  };\n  /**\n   * Sets the blend mode of the renderer.\n   *\n   * @param {number} blendMode - See {@link PIXI.BLEND_MODES} for valid values.\n   */\n\n\n  CanvasRenderer.prototype.setBlendMode = function setBlendMode(blendMode) {\n    if (this._activeBlendMode === blendMode) {\n      return;\n    }\n\n    this._activeBlendMode = blendMode;\n    this.context.globalCompositeOperation = this.blendModes[blendMode];\n  };\n  /**\n   * Removes everything from the renderer and optionally removes the Canvas DOM element.\n   *\n   * @param {boolean} [removeView=false] - Removes the Canvas element from the DOM.\n   */\n\n\n  CanvasRenderer.prototype.destroy = function destroy(removeView) {\n    this.destroyPlugins(); // call the base destroy\n\n    _SystemRenderer.prototype.destroy.call(this, removeView);\n\n    this.context = null;\n    this.refresh = true;\n    this.maskManager.destroy();\n    this.maskManager = null;\n    this.smoothProperty = null;\n  };\n  /**\n   * Resizes the canvas view to the specified width and height.\n   *\n   * @extends PIXI.SystemRenderer#resize\n   *\n   * @param {number} screenWidth - the new width of the screen\n   * @param {number} screenHeight - the new height of the screen\n   */\n\n\n  CanvasRenderer.prototype.resize = function resize(screenWidth, screenHeight) {\n    _SystemRenderer.prototype.resize.call(this, screenWidth, screenHeight); // reset the scale mode.. oddly this seems to be reset when the canvas is resized.\n    // surely a browser bug?? Let PixiJS fix that for you..\n\n\n    if (this.smoothProperty) {\n      this.rootContext[this.smoothProperty] = _settings2.default.SCALE_MODE === _const.SCALE_MODES.LINEAR;\n    }\n  };\n  /**\n   * Checks if blend mode has changed.\n   */\n\n\n  CanvasRenderer.prototype.invalidateBlendMode = function invalidateBlendMode() {\n    this._activeBlendMode = this.blendModes.indexOf(this.context.globalCompositeOperation);\n  };\n\n  return CanvasRenderer;\n}(_SystemRenderer3.default);\n/**\n * Collection of installed plugins. These are included by default in PIXI, but can be excluded\n * by creating a custom build. Consult the README for more information about creating custom\n * builds and excluding plugins.\n * @name PIXI.CanvasRenderer#plugins\n * @type {object}\n * @readonly\n * @property {PIXI.accessibility.AccessibilityManager} accessibility Support tabbing interactive elements.\n * @property {PIXI.extract.CanvasExtract} extract Extract image data from renderer.\n * @property {PIXI.interaction.InteractionManager} interaction Handles mouse, touch and pointer events.\n * @property {PIXI.prepare.CanvasPrepare} prepare Pre-render display objects.\n */\n\n/**\n * Adds a plugin to the renderer.\n *\n * @method PIXI.CanvasRenderer#registerPlugin\n * @param {string} pluginName - The name of the plugin.\n * @param {Function} ctor - The constructor function or class for the plugin.\n */\n\n\nexports.default = CanvasRenderer;\n\n_utils.pluginTarget.mixin(CanvasRenderer);","map":null,"metadata":{},"sourceType":"script"}