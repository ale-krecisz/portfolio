{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _const = require('../../../const');\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n/**\n * A set of functions used to handle masking.\n *\n * @class\n * @memberof PIXI\n */\n\n\nvar CanvasMaskManager = function () {\n  /**\n   * @param {PIXI.CanvasRenderer} renderer - The canvas renderer.\n   */\n  function CanvasMaskManager(renderer) {\n    _classCallCheck(this, CanvasMaskManager);\n\n    this.renderer = renderer;\n  }\n  /**\n   * This method adds it to the current stack of masks.\n   *\n   * @param {object} maskData - the maskData that will be pushed\n   */\n\n\n  CanvasMaskManager.prototype.pushMask = function pushMask(maskData) {\n    var renderer = this.renderer;\n    renderer.context.save();\n    var cacheAlpha = maskData.alpha;\n    var transform = maskData.transform.worldTransform;\n    var resolution = renderer.resolution;\n    renderer.context.setTransform(transform.a * resolution, transform.b * resolution, transform.c * resolution, transform.d * resolution, transform.tx * resolution, transform.ty * resolution); // TODO suport sprite alpha masks??\n    // lots of effort required. If demand is great enough..\n\n    if (!maskData._texture) {\n      this.renderGraphicsShape(maskData);\n      renderer.context.clip();\n    }\n\n    maskData.worldAlpha = cacheAlpha;\n  };\n  /**\n   * Renders a PIXI.Graphics shape.\n   *\n   * @param {PIXI.Graphics} graphics - The object to render.\n   */\n\n\n  CanvasMaskManager.prototype.renderGraphicsShape = function renderGraphicsShape(graphics) {\n    var context = this.renderer.context;\n    var len = graphics.graphicsData.length;\n\n    if (len === 0) {\n      return;\n    }\n\n    context.beginPath();\n\n    for (var i = 0; i < len; i++) {\n      var data = graphics.graphicsData[i];\n      var shape = data.shape;\n\n      if (data.type === _const.SHAPES.POLY) {\n        var points = shape.points;\n        context.moveTo(points[0], points[1]);\n\n        for (var j = 1; j < points.length / 2; j++) {\n          context.lineTo(points[j * 2], points[j * 2 + 1]);\n        } // if the first and last point are the same close the path - much neater :)\n\n\n        if (points[0] === points[points.length - 2] && points[1] === points[points.length - 1]) {\n          context.closePath();\n        }\n      } else if (data.type === _const.SHAPES.RECT) {\n        context.rect(shape.x, shape.y, shape.width, shape.height);\n        context.closePath();\n      } else if (data.type === _const.SHAPES.CIRC) {\n        // TODO - need to be Undefined!\n        context.arc(shape.x, shape.y, shape.radius, 0, 2 * Math.PI);\n        context.closePath();\n      } else if (data.type === _const.SHAPES.ELIP) {\n        // ellipse code taken from: http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas\n        var w = shape.width * 2;\n        var h = shape.height * 2;\n        var x = shape.x - w / 2;\n        var y = shape.y - h / 2;\n        var kappa = 0.5522848;\n        var ox = w / 2 * kappa; // control point offset horizontal\n\n        var oy = h / 2 * kappa; // control point offset vertical\n\n        var xe = x + w; // x-end\n\n        var ye = y + h; // y-end\n\n        var xm = x + w / 2; // x-middle\n\n        var ym = y + h / 2; // y-middle\n\n        context.moveTo(x, ym);\n        context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n        context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n        context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n        context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n        context.closePath();\n      } else if (data.type === _const.SHAPES.RREC) {\n        var rx = shape.x;\n        var ry = shape.y;\n        var width = shape.width;\n        var height = shape.height;\n        var radius = shape.radius;\n        var maxRadius = Math.min(width, height) / 2 | 0;\n        radius = radius > maxRadius ? maxRadius : radius;\n        context.moveTo(rx, ry + radius);\n        context.lineTo(rx, ry + height - radius);\n        context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);\n        context.lineTo(rx + width - radius, ry + height);\n        context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);\n        context.lineTo(rx + width, ry + radius);\n        context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);\n        context.lineTo(rx + radius, ry);\n        context.quadraticCurveTo(rx, ry, rx, ry + radius);\n        context.closePath();\n      }\n    }\n  };\n  /**\n   * Restores the current drawing context to the state it was before the mask was applied.\n   *\n   * @param {PIXI.CanvasRenderer} renderer - The renderer context to use.\n   */\n\n\n  CanvasMaskManager.prototype.popMask = function popMask(renderer) {\n    renderer.context.restore();\n  };\n  /**\n   * Destroys this canvas mask manager.\n   *\n   */\n\n\n  CanvasMaskManager.prototype.destroy = function destroy() {\n    /* empty */\n  };\n\n  return CanvasMaskManager;\n}();\n\nexports.default = CanvasMaskManager;","map":null,"metadata":{},"sourceType":"script"}