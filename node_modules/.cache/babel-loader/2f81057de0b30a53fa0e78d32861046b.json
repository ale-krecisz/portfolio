{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _GroupD = require('../math/GroupD8');\n\nvar _GroupD2 = _interopRequireDefault(_GroupD);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n/**\n * A standard object to store the Uvs of a texture\n *\n * @class\n * @private\n * @memberof PIXI\n */\n\n\nvar TextureUvs = function () {\n  /**\n   *\n   */\n  function TextureUvs() {\n    _classCallCheck(this, TextureUvs);\n\n    this.x0 = 0;\n    this.y0 = 0;\n    this.x1 = 1;\n    this.y1 = 0;\n    this.x2 = 1;\n    this.y2 = 1;\n    this.x3 = 0;\n    this.y3 = 1;\n    this.uvsUint32 = new Uint32Array(4);\n  }\n  /**\n   * Sets the texture Uvs based on the given frame information.\n   *\n   * @private\n   * @param {PIXI.Rectangle} frame - The frame of the texture\n   * @param {PIXI.Rectangle} baseFrame - The base frame of the texture\n   * @param {number} rotate - Rotation of frame, see {@link PIXI.GroupD8}\n   */\n\n\n  TextureUvs.prototype.set = function set(frame, baseFrame, rotate) {\n    var tw = baseFrame.width;\n    var th = baseFrame.height;\n\n    if (rotate) {\n      // width and height div 2 div baseFrame size\n      var w2 = frame.width / 2 / tw;\n      var h2 = frame.height / 2 / th; // coordinates of center\n\n      var cX = frame.x / tw + w2;\n      var cY = frame.y / th + h2;\n      rotate = _GroupD2.default.add(rotate, _GroupD2.default.NW); // NW is top-left corner\n\n      this.x0 = cX + w2 * _GroupD2.default.uX(rotate);\n      this.y0 = cY + h2 * _GroupD2.default.uY(rotate);\n      rotate = _GroupD2.default.add(rotate, 2); // rotate 90 degrees clockwise\n\n      this.x1 = cX + w2 * _GroupD2.default.uX(rotate);\n      this.y1 = cY + h2 * _GroupD2.default.uY(rotate);\n      rotate = _GroupD2.default.add(rotate, 2);\n      this.x2 = cX + w2 * _GroupD2.default.uX(rotate);\n      this.y2 = cY + h2 * _GroupD2.default.uY(rotate);\n      rotate = _GroupD2.default.add(rotate, 2);\n      this.x3 = cX + w2 * _GroupD2.default.uX(rotate);\n      this.y3 = cY + h2 * _GroupD2.default.uY(rotate);\n    } else {\n      this.x0 = frame.x / tw;\n      this.y0 = frame.y / th;\n      this.x1 = (frame.x + frame.width) / tw;\n      this.y1 = frame.y / th;\n      this.x2 = (frame.x + frame.width) / tw;\n      this.y2 = (frame.y + frame.height) / th;\n      this.x3 = frame.x / tw;\n      this.y3 = (frame.y + frame.height) / th;\n    }\n\n    this.uvsUint32[0] = (Math.round(this.y0 * 65535) & 0xFFFF) << 16 | Math.round(this.x0 * 65535) & 0xFFFF;\n    this.uvsUint32[1] = (Math.round(this.y1 * 65535) & 0xFFFF) << 16 | Math.round(this.x1 * 65535) & 0xFFFF;\n    this.uvsUint32[2] = (Math.round(this.y2 * 65535) & 0xFFFF) << 16 | Math.round(this.x2 * 65535) & 0xFFFF;\n    this.uvsUint32[3] = (Math.round(this.y3 * 65535) & 0xFFFF) << 16 | Math.round(this.x3 * 65535) & 0xFFFF;\n  };\n\n  return TextureUvs;\n}();\n\nexports.default = TextureUvs;","map":null,"metadata":{},"sourceType":"script"}