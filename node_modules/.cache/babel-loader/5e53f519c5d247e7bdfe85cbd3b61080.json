{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _core = require('../../core');\n\nvar core = _interopRequireWildcard(_core);\n\nvar _Mesh = require('../Mesh');\n\nvar _Mesh2 = _interopRequireDefault(_Mesh);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n/**\n * Renderer dedicated to meshes.\n *\n * @class\n * @private\n * @memberof PIXI\n */\n\n\nvar MeshSpriteRenderer = function () {\n  /**\n   * @param {PIXI.CanvasRenderer} renderer - The renderer this downport works for\n   */\n  function MeshSpriteRenderer(renderer) {\n    _classCallCheck(this, MeshSpriteRenderer);\n\n    this.renderer = renderer;\n  }\n  /**\n   * Renders the Mesh\n   *\n   * @param {PIXI.mesh.Mesh} mesh - the Mesh to render\n   */\n\n\n  MeshSpriteRenderer.prototype.render = function render(mesh) {\n    var renderer = this.renderer;\n    var context = renderer.context;\n    var transform = mesh.worldTransform;\n    var res = renderer.resolution;\n\n    if (renderer.roundPixels) {\n      context.setTransform(transform.a * res, transform.b * res, transform.c * res, transform.d * res, transform.tx * res | 0, transform.ty * res | 0);\n    } else {\n      context.setTransform(transform.a * res, transform.b * res, transform.c * res, transform.d * res, transform.tx * res, transform.ty * res);\n    }\n\n    renderer.context.globalAlpha = mesh.worldAlpha;\n    renderer.setBlendMode(mesh.blendMode);\n\n    if (mesh.drawMode === _Mesh2.default.DRAW_MODES.TRIANGLE_MESH) {\n      this._renderTriangleMesh(mesh);\n    } else {\n      this._renderTriangles(mesh);\n    }\n  };\n  /**\n   * Draws the object in Triangle Mesh mode\n   *\n   * @private\n   * @param {PIXI.mesh.Mesh} mesh - the Mesh to render\n   */\n\n\n  MeshSpriteRenderer.prototype._renderTriangleMesh = function _renderTriangleMesh(mesh) {\n    // draw triangles!!\n    var length = mesh.vertices.length / 2;\n\n    for (var i = 0; i < length - 2; i++) {\n      // draw some triangles!\n      var index = i * 2;\n\n      this._renderDrawTriangle(mesh, index, index + 2, index + 4);\n    }\n  };\n  /**\n   * Draws the object in triangle mode using canvas\n   *\n   * @private\n   * @param {PIXI.mesh.Mesh} mesh - the current mesh\n   */\n\n\n  MeshSpriteRenderer.prototype._renderTriangles = function _renderTriangles(mesh) {\n    // draw triangles!!\n    var indices = mesh.indices;\n    var length = indices.length;\n\n    for (var i = 0; i < length; i += 3) {\n      // draw some triangles!\n      var index0 = indices[i] * 2;\n      var index1 = indices[i + 1] * 2;\n      var index2 = indices[i + 2] * 2;\n\n      this._renderDrawTriangle(mesh, index0, index1, index2);\n    }\n  };\n  /**\n   * Draws one of the triangles that from the Mesh\n   *\n   * @private\n   * @param {PIXI.mesh.Mesh} mesh - the current mesh\n   * @param {number} index0 - the index of the first vertex\n   * @param {number} index1 - the index of the second vertex\n   * @param {number} index2 - the index of the third vertex\n   */\n\n\n  MeshSpriteRenderer.prototype._renderDrawTriangle = function _renderDrawTriangle(mesh, index0, index1, index2) {\n    var context = this.renderer.context;\n    var uvs = mesh.uvs;\n    var vertices = mesh.vertices;\n    var texture = mesh._texture;\n\n    if (!texture.valid) {\n      return;\n    }\n\n    var base = texture.baseTexture;\n    var textureSource = base.source;\n    var textureWidth = base.width;\n    var textureHeight = base.height;\n    var u0 = void 0;\n    var u1 = void 0;\n    var u2 = void 0;\n    var v0 = void 0;\n    var v1 = void 0;\n    var v2 = void 0;\n\n    if (mesh.uploadUvTransform) {\n      var ut = mesh._uvTransform.mapCoord;\n      u0 = (uvs[index0] * ut.a + uvs[index0 + 1] * ut.c + ut.tx) * base.width;\n      u1 = (uvs[index1] * ut.a + uvs[index1 + 1] * ut.c + ut.tx) * base.width;\n      u2 = (uvs[index2] * ut.a + uvs[index2 + 1] * ut.c + ut.tx) * base.width;\n      v0 = (uvs[index0] * ut.b + uvs[index0 + 1] * ut.d + ut.ty) * base.height;\n      v1 = (uvs[index1] * ut.b + uvs[index1 + 1] * ut.d + ut.ty) * base.height;\n      v2 = (uvs[index2] * ut.b + uvs[index2 + 1] * ut.d + ut.ty) * base.height;\n    } else {\n      u0 = uvs[index0] * base.width;\n      u1 = uvs[index1] * base.width;\n      u2 = uvs[index2] * base.width;\n      v0 = uvs[index0 + 1] * base.height;\n      v1 = uvs[index1 + 1] * base.height;\n      v2 = uvs[index2 + 1] * base.height;\n    }\n\n    var x0 = vertices[index0];\n    var x1 = vertices[index1];\n    var x2 = vertices[index2];\n    var y0 = vertices[index0 + 1];\n    var y1 = vertices[index1 + 1];\n    var y2 = vertices[index2 + 1];\n    var canvasPadding = mesh.canvasPadding / this.renderer.resolution;\n\n    if (canvasPadding > 0) {\n      var paddingX = canvasPadding / Math.abs(mesh.worldTransform.a);\n      var paddingY = canvasPadding / Math.abs(mesh.worldTransform.d);\n      var centerX = (x0 + x1 + x2) / 3;\n      var centerY = (y0 + y1 + y2) / 3;\n      var normX = x0 - centerX;\n      var normY = y0 - centerY;\n      var dist = Math.sqrt(normX * normX + normY * normY);\n      x0 = centerX + normX / dist * (dist + paddingX);\n      y0 = centerY + normY / dist * (dist + paddingY); //\n\n      normX = x1 - centerX;\n      normY = y1 - centerY;\n      dist = Math.sqrt(normX * normX + normY * normY);\n      x1 = centerX + normX / dist * (dist + paddingX);\n      y1 = centerY + normY / dist * (dist + paddingY);\n      normX = x2 - centerX;\n      normY = y2 - centerY;\n      dist = Math.sqrt(normX * normX + normY * normY);\n      x2 = centerX + normX / dist * (dist + paddingX);\n      y2 = centerY + normY / dist * (dist + paddingY);\n    }\n\n    context.save();\n    context.beginPath();\n    context.moveTo(x0, y0);\n    context.lineTo(x1, y1);\n    context.lineTo(x2, y2);\n    context.closePath();\n    context.clip(); // Compute matrix transform\n\n    var delta = u0 * v1 + v0 * u2 + u1 * v2 - v1 * u2 - v0 * u1 - u0 * v2;\n    var deltaA = x0 * v1 + v0 * x2 + x1 * v2 - v1 * x2 - v0 * x1 - x0 * v2;\n    var deltaB = u0 * x1 + x0 * u2 + u1 * x2 - x1 * u2 - x0 * u1 - u0 * x2;\n    var deltaC = u0 * v1 * x2 + v0 * x1 * u2 + x0 * u1 * v2 - x0 * v1 * u2 - v0 * u1 * x2 - u0 * x1 * v2;\n    var deltaD = y0 * v1 + v0 * y2 + y1 * v2 - v1 * y2 - v0 * y1 - y0 * v2;\n    var deltaE = u0 * y1 + y0 * u2 + u1 * y2 - y1 * u2 - y0 * u1 - u0 * y2;\n    var deltaF = u0 * v1 * y2 + v0 * y1 * u2 + y0 * u1 * v2 - y0 * v1 * u2 - v0 * u1 * y2 - u0 * y1 * v2;\n    context.transform(deltaA / delta, deltaD / delta, deltaB / delta, deltaE / delta, deltaC / delta, deltaF / delta);\n    context.drawImage(textureSource, 0, 0, textureWidth * base.resolution, textureHeight * base.resolution, 0, 0, textureWidth, textureHeight);\n    context.restore();\n    this.renderer.invalidateBlendMode();\n  };\n  /**\n   * Renders a flat Mesh\n   *\n   * @private\n   * @param {PIXI.mesh.Mesh} mesh - The Mesh to render\n   */\n\n\n  MeshSpriteRenderer.prototype.renderMeshFlat = function renderMeshFlat(mesh) {\n    var context = this.renderer.context;\n    var vertices = mesh.vertices;\n    var length = vertices.length / 2; // this.count++;\n\n    context.beginPath();\n\n    for (var i = 1; i < length - 2; ++i) {\n      // draw some triangles!\n      var index = i * 2;\n      var x0 = vertices[index];\n      var y0 = vertices[index + 1];\n      var x1 = vertices[index + 2];\n      var y1 = vertices[index + 3];\n      var x2 = vertices[index + 4];\n      var y2 = vertices[index + 5];\n      context.moveTo(x0, y0);\n      context.lineTo(x1, y1);\n      context.lineTo(x2, y2);\n    }\n\n    context.fillStyle = '#FF0000';\n    context.fill();\n    context.closePath();\n  };\n  /**\n   * destroy the the renderer.\n   *\n   */\n\n\n  MeshSpriteRenderer.prototype.destroy = function destroy() {\n    this.renderer = null;\n  };\n\n  return MeshSpriteRenderer;\n}();\n\nexports.default = MeshSpriteRenderer;\ncore.CanvasRenderer.registerPlugin('mesh', MeshSpriteRenderer);","map":null,"metadata":{},"sourceType":"script"}