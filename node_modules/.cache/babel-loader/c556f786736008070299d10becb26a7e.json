{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _pixiGlCore = require('pixi-gl-core');\n\nvar _pixiGlCore2 = _interopRequireDefault(_pixiGlCore);\n\nvar _createIndicesForQuads = require('../../core/utils/createIndicesForQuads');\n\nvar _createIndicesForQuads2 = _interopRequireDefault(_createIndicesForQuads);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n/**\n * @author Mat Groves\n *\n * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/\n * for creating the original PixiJS version!\n * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that\n * they now share 4 bytes on the vertex buffer\n *\n * Heavily inspired by LibGDX's ParticleBuffer:\n * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/ParticleBuffer.java\n */\n\n/**\n * The particle buffer manages the static and dynamic buffers for a particle container.\n *\n * @class\n * @private\n * @memberof PIXI\n */\n\n\nvar ParticleBuffer = function () {\n  /**\n   * @param {WebGLRenderingContext} gl - The rendering context.\n   * @param {object} properties - The properties to upload.\n   * @param {boolean[]} dynamicPropertyFlags - Flags for which properties are dynamic.\n   * @param {number} size - The size of the batch.\n   */\n  function ParticleBuffer(gl, properties, dynamicPropertyFlags, size) {\n    _classCallCheck(this, ParticleBuffer);\n    /**\n     * The current WebGL drawing context.\n     *\n     * @member {WebGLRenderingContext}\n     */\n\n\n    this.gl = gl;\n    /**\n     * The number of particles the buffer can hold\n     *\n     * @member {number}\n     */\n\n    this.size = size;\n    /**\n     * A list of the properties that are dynamic.\n     *\n     * @member {object[]}\n     */\n\n    this.dynamicProperties = [];\n    /**\n     * A list of the properties that are static.\n     *\n     * @member {object[]}\n     */\n\n    this.staticProperties = [];\n\n    for (var i = 0; i < properties.length; ++i) {\n      var property = properties[i]; // Make copy of properties object so that when we edit the offset it doesn't\n      // change all other instances of the object literal\n\n      property = {\n        attribute: property.attribute,\n        size: property.size,\n        uploadFunction: property.uploadFunction,\n        unsignedByte: property.unsignedByte,\n        offset: property.offset\n      };\n\n      if (dynamicPropertyFlags[i]) {\n        this.dynamicProperties.push(property);\n      } else {\n        this.staticProperties.push(property);\n      }\n    }\n\n    this.staticStride = 0;\n    this.staticBuffer = null;\n    this.staticData = null;\n    this.staticDataUint32 = null;\n    this.dynamicStride = 0;\n    this.dynamicBuffer = null;\n    this.dynamicData = null;\n    this.dynamicDataUint32 = null;\n    this._updateID = 0;\n    this.initBuffers();\n  }\n  /**\n   * Sets up the renderer context and necessary buffers.\n   *\n   * @private\n   */\n\n\n  ParticleBuffer.prototype.initBuffers = function initBuffers() {\n    var gl = this.gl;\n    var dynamicOffset = 0;\n    /**\n     * Holds the indices of the geometry (quads) to draw\n     *\n     * @member {Uint16Array}\n     */\n\n    this.indices = (0, _createIndicesForQuads2.default)(this.size);\n    this.indexBuffer = _pixiGlCore2.default.GLBuffer.createIndexBuffer(gl, this.indices, gl.STATIC_DRAW);\n    this.dynamicStride = 0;\n\n    for (var i = 0; i < this.dynamicProperties.length; ++i) {\n      var property = this.dynamicProperties[i];\n      property.offset = dynamicOffset;\n      dynamicOffset += property.size;\n      this.dynamicStride += property.size;\n    }\n\n    var dynBuffer = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);\n    this.dynamicData = new Float32Array(dynBuffer);\n    this.dynamicDataUint32 = new Uint32Array(dynBuffer);\n    this.dynamicBuffer = _pixiGlCore2.default.GLBuffer.createVertexBuffer(gl, dynBuffer, gl.STREAM_DRAW); // static //\n\n    var staticOffset = 0;\n    this.staticStride = 0;\n\n    for (var _i = 0; _i < this.staticProperties.length; ++_i) {\n      var _property = this.staticProperties[_i];\n      _property.offset = staticOffset;\n      staticOffset += _property.size;\n      this.staticStride += _property.size;\n    }\n\n    var statBuffer = new ArrayBuffer(this.size * this.staticStride * 4 * 4);\n    this.staticData = new Float32Array(statBuffer);\n    this.staticDataUint32 = new Uint32Array(statBuffer);\n    this.staticBuffer = _pixiGlCore2.default.GLBuffer.createVertexBuffer(gl, statBuffer, gl.STATIC_DRAW);\n    this.vao = new _pixiGlCore2.default.VertexArrayObject(gl).addIndex(this.indexBuffer);\n\n    for (var _i2 = 0; _i2 < this.dynamicProperties.length; ++_i2) {\n      var _property2 = this.dynamicProperties[_i2];\n\n      if (_property2.unsignedByte) {\n        this.vao.addAttribute(this.dynamicBuffer, _property2.attribute, gl.UNSIGNED_BYTE, true, this.dynamicStride * 4, _property2.offset * 4);\n      } else {\n        this.vao.addAttribute(this.dynamicBuffer, _property2.attribute, gl.FLOAT, false, this.dynamicStride * 4, _property2.offset * 4);\n      }\n    }\n\n    for (var _i3 = 0; _i3 < this.staticProperties.length; ++_i3) {\n      var _property3 = this.staticProperties[_i3];\n\n      if (_property3.unsignedByte) {\n        this.vao.addAttribute(this.staticBuffer, _property3.attribute, gl.UNSIGNED_BYTE, true, this.staticStride * 4, _property3.offset * 4);\n      } else {\n        this.vao.addAttribute(this.staticBuffer, _property3.attribute, gl.FLOAT, false, this.staticStride * 4, _property3.offset * 4);\n      }\n    }\n  };\n  /**\n   * Uploads the dynamic properties.\n   *\n   * @param {PIXI.DisplayObject[]} children - The children to upload.\n   * @param {number} startIndex - The index to start at.\n   * @param {number} amount - The number to upload.\n   */\n\n\n  ParticleBuffer.prototype.uploadDynamic = function uploadDynamic(children, startIndex, amount) {\n    for (var i = 0; i < this.dynamicProperties.length; i++) {\n      var property = this.dynamicProperties[i];\n      property.uploadFunction(children, startIndex, amount, property.unsignedByte ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, property.offset);\n    }\n\n    this.dynamicBuffer.upload();\n  };\n  /**\n   * Uploads the static properties.\n   *\n   * @param {PIXI.DisplayObject[]} children - The children to upload.\n   * @param {number} startIndex - The index to start at.\n   * @param {number} amount - The number to upload.\n   */\n\n\n  ParticleBuffer.prototype.uploadStatic = function uploadStatic(children, startIndex, amount) {\n    for (var i = 0; i < this.staticProperties.length; i++) {\n      var property = this.staticProperties[i];\n      property.uploadFunction(children, startIndex, amount, property.unsignedByte ? this.staticDataUint32 : this.staticData, this.staticStride, property.offset);\n    }\n\n    this.staticBuffer.upload();\n  };\n  /**\n   * Destroys the ParticleBuffer.\n   *\n   */\n\n\n  ParticleBuffer.prototype.destroy = function destroy() {\n    this.dynamicProperties = null;\n    this.dynamicBuffer.destroy();\n    this.dynamicBuffer = null;\n    this.dynamicData = null;\n    this.dynamicDataUint32 = null;\n    this.staticProperties = null;\n    this.staticBuffer.destroy();\n    this.staticBuffer = null;\n    this.staticData = null;\n    this.staticDataUint32 = null;\n  };\n\n  return ParticleBuffer;\n}();\n\nexports.default = ParticleBuffer;","map":null,"metadata":{},"sourceType":"script"}