{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _CanvasRenderer = require('../../renderers/canvas/CanvasRenderer');\n\nvar _CanvasRenderer2 = _interopRequireDefault(_CanvasRenderer);\n\nvar _const = require('../../const');\n\nvar _math = require('../../math');\n\nvar _CanvasTinter = require('./CanvasTinter');\n\nvar _CanvasTinter2 = _interopRequireDefault(_CanvasTinter);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar canvasRenderWorldTransform = new _math.Matrix();\n/**\n * @author Mat Groves\n *\n * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/\n * for creating the original PixiJS version!\n * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they now\n * share 4 bytes on the vertex buffer\n *\n * Heavily inspired by LibGDX's CanvasSpriteRenderer:\n * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/CanvasSpriteRenderer.java\n */\n\n/**\n * Renderer dedicated to drawing and batching sprites.\n *\n * @class\n * @private\n * @memberof PIXI\n */\n\nvar CanvasSpriteRenderer = function () {\n  /**\n   * @param {PIXI.WebGLRenderer} renderer -The renderer sprite this batch works for.\n   */\n  function CanvasSpriteRenderer(renderer) {\n    _classCallCheck(this, CanvasSpriteRenderer);\n\n    this.renderer = renderer;\n  }\n  /**\n   * Renders the sprite object.\n   *\n   * @param {PIXI.Sprite} sprite - the sprite to render when using this spritebatch\n   */\n\n\n  CanvasSpriteRenderer.prototype.render = function render(sprite) {\n    var texture = sprite._texture;\n    var renderer = this.renderer;\n    var width = texture._frame.width;\n    var height = texture._frame.height;\n    var wt = sprite.transform.worldTransform;\n    var dx = 0;\n    var dy = 0;\n\n    if (texture.orig.width <= 0 || texture.orig.height <= 0 || !texture.baseTexture.source) {\n      return;\n    }\n\n    renderer.setBlendMode(sprite.blendMode); //  Ignore null sources\n\n    if (texture.valid) {\n      renderer.context.globalAlpha = sprite.worldAlpha; // If smoothingEnabled is supported and we need to change the smoothing property for sprite texture\n\n      var smoothingEnabled = texture.baseTexture.scaleMode === _const.SCALE_MODES.LINEAR;\n\n      if (renderer.smoothProperty && renderer.context[renderer.smoothProperty] !== smoothingEnabled) {\n        renderer.context[renderer.smoothProperty] = smoothingEnabled;\n      }\n\n      if (texture.trim) {\n        dx = texture.trim.width / 2 + texture.trim.x - sprite.anchor.x * texture.orig.width;\n        dy = texture.trim.height / 2 + texture.trim.y - sprite.anchor.y * texture.orig.height;\n      } else {\n        dx = (0.5 - sprite.anchor.x) * texture.orig.width;\n        dy = (0.5 - sprite.anchor.y) * texture.orig.height;\n      }\n\n      if (texture.rotate) {\n        wt.copy(canvasRenderWorldTransform);\n        wt = canvasRenderWorldTransform;\n\n        _math.GroupD8.matrixAppendRotationInv(wt, texture.rotate, dx, dy); // the anchor has already been applied above, so lets set it to zero\n\n\n        dx = 0;\n        dy = 0;\n      }\n\n      dx -= width / 2;\n      dy -= height / 2; // Allow for pixel rounding\n\n      if (renderer.roundPixels) {\n        renderer.context.setTransform(wt.a, wt.b, wt.c, wt.d, wt.tx * renderer.resolution | 0, wt.ty * renderer.resolution | 0);\n        dx = dx | 0;\n        dy = dy | 0;\n      } else {\n        renderer.context.setTransform(wt.a, wt.b, wt.c, wt.d, wt.tx * renderer.resolution, wt.ty * renderer.resolution);\n      }\n\n      var resolution = texture.baseTexture.resolution;\n\n      if (sprite.tint !== 0xFFFFFF) {\n        if (sprite.cachedTint !== sprite.tint || sprite.tintedTexture.tintId !== sprite._texture._updateID) {\n          sprite.cachedTint = sprite.tint; // TODO clean up caching - how to clean up the caches?\n\n          sprite.tintedTexture = _CanvasTinter2.default.getTintedTexture(sprite, sprite.tint);\n        }\n\n        renderer.context.drawImage(sprite.tintedTexture, 0, 0, width * resolution, height * resolution, dx * renderer.resolution, dy * renderer.resolution, width * renderer.resolution, height * renderer.resolution);\n      } else {\n        renderer.context.drawImage(texture.baseTexture.source, texture._frame.x * resolution, texture._frame.y * resolution, width * resolution, height * resolution, dx * renderer.resolution, dy * renderer.resolution, width * renderer.resolution, height * renderer.resolution);\n      }\n    }\n  };\n  /**\n   * destroy the sprite object.\n   *\n   */\n\n\n  CanvasSpriteRenderer.prototype.destroy = function destroy() {\n    this.renderer = null;\n  };\n\n  return CanvasSpriteRenderer;\n}();\n\nexports.default = CanvasSpriteRenderer;\n\n_CanvasRenderer2.default.registerPlugin('sprite', CanvasSpriteRenderer);","map":null,"metadata":{},"sourceType":"script"}