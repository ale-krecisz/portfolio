{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _utils = require('../../utils');\n\nvar _const = require('../../const');\n\nvar _ObjectRenderer2 = require('../../renderers/webgl/utils/ObjectRenderer');\n\nvar _ObjectRenderer3 = _interopRequireDefault(_ObjectRenderer2);\n\nvar _WebGLRenderer = require('../../renderers/webgl/WebGLRenderer');\n\nvar _WebGLRenderer2 = _interopRequireDefault(_WebGLRenderer);\n\nvar _WebGLGraphicsData = require('./WebGLGraphicsData');\n\nvar _WebGLGraphicsData2 = _interopRequireDefault(_WebGLGraphicsData);\n\nvar _PrimitiveShader = require('./shaders/PrimitiveShader');\n\nvar _PrimitiveShader2 = _interopRequireDefault(_PrimitiveShader);\n\nvar _buildPoly = require('./utils/buildPoly');\n\nvar _buildPoly2 = _interopRequireDefault(_buildPoly);\n\nvar _buildRectangle = require('./utils/buildRectangle');\n\nvar _buildRectangle2 = _interopRequireDefault(_buildRectangle);\n\nvar _buildRoundedRectangle = require('./utils/buildRoundedRectangle');\n\nvar _buildRoundedRectangle2 = _interopRequireDefault(_buildRoundedRectangle);\n\nvar _buildCircle = require('./utils/buildCircle');\n\nvar _buildCircle2 = _interopRequireDefault(_buildCircle);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n/**\n * Renders the graphics object.\n *\n * @class\n * @memberof PIXI\n * @extends PIXI.ObjectRenderer\n */\n\n\nvar GraphicsRenderer = function (_ObjectRenderer) {\n  _inherits(GraphicsRenderer, _ObjectRenderer);\n  /**\n   * @param {PIXI.WebGLRenderer} renderer - The renderer this object renderer works for.\n   */\n\n\n  function GraphicsRenderer(renderer) {\n    _classCallCheck(this, GraphicsRenderer);\n\n    var _this = _possibleConstructorReturn(this, _ObjectRenderer.call(this, renderer));\n\n    _this.graphicsDataPool = [];\n    _this.primitiveShader = null;\n    _this.gl = renderer.gl; // easy access!\n\n    _this.CONTEXT_UID = 0;\n    return _this;\n  }\n  /**\n   * Called when there is a WebGL context change\n   *\n   * @private\n   *\n   */\n\n\n  GraphicsRenderer.prototype.onContextChange = function onContextChange() {\n    this.gl = this.renderer.gl;\n    this.CONTEXT_UID = this.renderer.CONTEXT_UID;\n    this.primitiveShader = new _PrimitiveShader2.default(this.gl);\n  };\n  /**\n   * Destroys this renderer.\n   *\n   */\n\n\n  GraphicsRenderer.prototype.destroy = function destroy() {\n    _ObjectRenderer3.default.prototype.destroy.call(this);\n\n    for (var i = 0; i < this.graphicsDataPool.length; ++i) {\n      this.graphicsDataPool[i].destroy();\n    }\n\n    this.graphicsDataPool = null;\n  };\n  /**\n   * Renders a graphics object.\n   *\n   * @param {PIXI.Graphics} graphics - The graphics object to render.\n   */\n\n\n  GraphicsRenderer.prototype.render = function render(graphics) {\n    var renderer = this.renderer;\n    var gl = renderer.gl;\n    var webGLData = void 0;\n    var webGL = graphics._webGL[this.CONTEXT_UID];\n\n    if (!webGL || graphics.dirty !== webGL.dirty) {\n      this.updateGraphics(graphics);\n      webGL = graphics._webGL[this.CONTEXT_UID];\n    } // This  could be speeded up for sure!\n\n\n    var shader = this.primitiveShader;\n    renderer.bindShader(shader);\n    renderer.state.setBlendMode(graphics.blendMode);\n\n    for (var i = 0, n = webGL.data.length; i < n; i++) {\n      webGLData = webGL.data[i];\n      var shaderTemp = webGLData.shader;\n      renderer.bindShader(shaderTemp);\n      shaderTemp.uniforms.translationMatrix = graphics.transform.worldTransform.toArray(true);\n      shaderTemp.uniforms.tint = (0, _utils.hex2rgb)(graphics.tint);\n      shaderTemp.uniforms.alpha = graphics.worldAlpha;\n      renderer.bindVao(webGLData.vao);\n\n      if (webGLData.nativeLines) {\n        gl.drawArrays(gl.LINES, 0, webGLData.points.length / 6);\n      } else {\n        webGLData.vao.draw(gl.TRIANGLE_STRIP, webGLData.indices.length);\n      }\n    }\n  };\n  /**\n   * Updates the graphics object\n   *\n   * @private\n   * @param {PIXI.Graphics} graphics - The graphics object to update\n   */\n\n\n  GraphicsRenderer.prototype.updateGraphics = function updateGraphics(graphics) {\n    var gl = this.renderer.gl; // get the contexts graphics object\n\n    var webGL = graphics._webGL[this.CONTEXT_UID]; // if the graphics object does not exist in the webGL context time to create it!\n\n    if (!webGL) {\n      webGL = graphics._webGL[this.CONTEXT_UID] = {\n        lastIndex: 0,\n        data: [],\n        gl: gl,\n        clearDirty: -1,\n        dirty: -1\n      };\n    } // flag the graphics as not dirty as we are about to update it...\n\n\n    webGL.dirty = graphics.dirty; // if the user cleared the graphics object we will need to clear every object\n\n    if (graphics.clearDirty !== webGL.clearDirty) {\n      webGL.clearDirty = graphics.clearDirty; // loop through and return all the webGLDatas to the object pool so than can be reused later on\n\n      for (var i = 0; i < webGL.data.length; i++) {\n        this.graphicsDataPool.push(webGL.data[i]);\n      } // clear the array and reset the index..\n\n\n      webGL.data.length = 0;\n      webGL.lastIndex = 0;\n    }\n\n    var webGLData = void 0;\n    var webGLDataNativeLines = void 0; // loop through the graphics datas and construct each one..\n    // if the object is a complex fill then the new stencil buffer technique will be used\n    // other wise graphics objects will be pushed into a batch..\n\n    for (var _i = webGL.lastIndex; _i < graphics.graphicsData.length; _i++) {\n      var data = graphics.graphicsData[_i]; // TODO - this can be simplified\n\n      webGLData = this.getWebGLData(webGL, 0);\n\n      if (data.nativeLines && data.lineWidth) {\n        webGLDataNativeLines = this.getWebGLData(webGL, 0, true);\n        webGL.lastIndex++;\n      }\n\n      if (data.type === _const.SHAPES.POLY) {\n        (0, _buildPoly2.default)(data, webGLData, webGLDataNativeLines);\n      }\n\n      if (data.type === _const.SHAPES.RECT) {\n        (0, _buildRectangle2.default)(data, webGLData, webGLDataNativeLines);\n      } else if (data.type === _const.SHAPES.CIRC || data.type === _const.SHAPES.ELIP) {\n        (0, _buildCircle2.default)(data, webGLData, webGLDataNativeLines);\n      } else if (data.type === _const.SHAPES.RREC) {\n        (0, _buildRoundedRectangle2.default)(data, webGLData, webGLDataNativeLines);\n      }\n\n      webGL.lastIndex++;\n    }\n\n    this.renderer.bindVao(null); // upload all the dirty data...\n\n    for (var _i2 = 0; _i2 < webGL.data.length; _i2++) {\n      webGLData = webGL.data[_i2];\n\n      if (webGLData.dirty) {\n        webGLData.upload();\n      }\n    }\n  };\n  /**\n   *\n   * @private\n   * @param {WebGLRenderingContext} gl - the current WebGL drawing context\n   * @param {number} type - TODO @Alvin\n   * @param {number} nativeLines - indicate whether the webGLData use for nativeLines.\n   * @return {*} TODO\n   */\n\n\n  GraphicsRenderer.prototype.getWebGLData = function getWebGLData(gl, type, nativeLines) {\n    var webGLData = gl.data[gl.data.length - 1];\n\n    if (!webGLData || webGLData.nativeLines !== nativeLines || webGLData.points.length > 320000) {\n      webGLData = this.graphicsDataPool.pop() || new _WebGLGraphicsData2.default(this.renderer.gl, this.primitiveShader, this.renderer.state.attribsState);\n      webGLData.nativeLines = nativeLines;\n      webGLData.reset(type);\n      gl.data.push(webGLData);\n    }\n\n    webGLData.dirty = true;\n    return webGLData;\n  };\n\n  return GraphicsRenderer;\n}(_ObjectRenderer3.default);\n\nexports.default = GraphicsRenderer;\n\n_WebGLRenderer2.default.registerPlugin('graphics', GraphicsRenderer);","map":null,"metadata":{},"sourceType":"script"}