{"ast":null,"code":"// state object//\nvar setVertexAttribArrays = require('./setVertexAttribArrays');\n/**\n * Helper class to work with WebGL VertexArrayObjects (vaos)\n * Only works if WebGL extensions are enabled (they usually are)\n *\n * @class\n * @memberof PIXI.glCore\n * @param gl {WebGLRenderingContext} The current WebGL rendering context\n */\n\n\nfunction VertexArrayObject(gl, state) {\n  this.nativeVaoExtension = null;\n\n  if (!VertexArrayObject.FORCE_NATIVE) {\n    this.nativeVaoExtension = gl.getExtension('OES_vertex_array_object') || gl.getExtension('MOZ_OES_vertex_array_object') || gl.getExtension('WEBKIT_OES_vertex_array_object');\n  }\n\n  this.nativeState = state;\n\n  if (this.nativeVaoExtension) {\n    this.nativeVao = this.nativeVaoExtension.createVertexArrayOES();\n    var maxAttribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS); // VAO - overwrite the state..\n\n    this.nativeState = {\n      tempAttribState: new Array(maxAttribs),\n      attribState: new Array(maxAttribs)\n    };\n  }\n  /**\n   * The current WebGL rendering context\n   *\n   * @member {WebGLRenderingContext}\n   */\n\n\n  this.gl = gl;\n  /**\n   * An array of attributes\n   *\n   * @member {Array}\n   */\n\n  this.attributes = [];\n  /**\n   * @member {PIXI.glCore.GLBuffer}\n   */\n\n  this.indexBuffer = null;\n  /**\n   * A boolean flag\n   *\n   * @member {Boolean}\n   */\n\n  this.dirty = false;\n}\n\nVertexArrayObject.prototype.constructor = VertexArrayObject;\nmodule.exports = VertexArrayObject;\n/**\n* Some devices behave a bit funny when using the newer extensions (im looking at you ipad 2!)\n* If you find on older devices that things have gone a bit weird then set this to true.\n*/\n\n/**\n * Lets the VAO know if you should use the WebGL extension or the native methods.\n * Some devices behave a bit funny when using the newer extensions (im looking at you ipad 2!)\n * If you find on older devices that things have gone a bit weird then set this to true.\n * @static\n * @property {Boolean} FORCE_NATIVE\n */\n\nVertexArrayObject.FORCE_NATIVE = false;\n/**\n * Binds the buffer\n */\n\nVertexArrayObject.prototype.bind = function () {\n  if (this.nativeVao) {\n    this.nativeVaoExtension.bindVertexArrayOES(this.nativeVao);\n\n    if (this.dirty) {\n      this.dirty = false;\n      this.activate();\n      return this;\n    }\n\n    if (this.indexBuffer) {\n      this.indexBuffer.bind();\n    }\n  } else {\n    this.activate();\n  }\n\n  return this;\n};\n/**\n * Unbinds the buffer\n */\n\n\nVertexArrayObject.prototype.unbind = function () {\n  if (this.nativeVao) {\n    this.nativeVaoExtension.bindVertexArrayOES(null);\n  }\n\n  return this;\n};\n/**\n * Uses this vao\n */\n\n\nVertexArrayObject.prototype.activate = function () {\n  var gl = this.gl;\n  var lastBuffer = null;\n\n  for (var i = 0; i < this.attributes.length; i++) {\n    var attrib = this.attributes[i];\n\n    if (lastBuffer !== attrib.buffer) {\n      attrib.buffer.bind();\n      lastBuffer = attrib.buffer;\n    }\n\n    gl.vertexAttribPointer(attrib.attribute.location, attrib.attribute.size, attrib.type || gl.FLOAT, attrib.normalized || false, attrib.stride || 0, attrib.start || 0);\n  }\n\n  setVertexAttribArrays(gl, this.attributes, this.nativeState);\n\n  if (this.indexBuffer) {\n    this.indexBuffer.bind();\n  }\n\n  return this;\n};\n/**\n *\n * @param buffer     {PIXI.gl.GLBuffer}\n * @param attribute  {*}\n * @param type       {String}\n * @param normalized {Boolean}\n * @param stride     {Number}\n * @param start      {Number}\n */\n\n\nVertexArrayObject.prototype.addAttribute = function (buffer, attribute, type, normalized, stride, start) {\n  this.attributes.push({\n    buffer: buffer,\n    attribute: attribute,\n    location: attribute.location,\n    type: type || this.gl.FLOAT,\n    normalized: normalized || false,\n    stride: stride || 0,\n    start: start || 0\n  });\n  this.dirty = true;\n  return this;\n};\n/**\n *\n * @param buffer   {PIXI.gl.GLBuffer}\n */\n\n\nVertexArrayObject.prototype.addIndex = function (buffer\n/*, options*/\n) {\n  this.indexBuffer = buffer;\n  this.dirty = true;\n  return this;\n};\n/**\n * Unbinds this vao and disables it\n */\n\n\nVertexArrayObject.prototype.clear = function () {\n  // var gl = this.gl;\n  // TODO - should this function unbind after clear?\n  // for now, no but lets see what happens in the real world!\n  if (this.nativeVao) {\n    this.nativeVaoExtension.bindVertexArrayOES(this.nativeVao);\n  }\n\n  this.attributes.length = 0;\n  this.indexBuffer = null;\n  return this;\n};\n/**\n * @param type  {Number}\n * @param size  {Number}\n * @param start {Number}\n */\n\n\nVertexArrayObject.prototype.draw = function (type, size, start) {\n  var gl = this.gl;\n\n  if (this.indexBuffer) {\n    gl.drawElements(type, size || this.indexBuffer.data.length, gl.UNSIGNED_SHORT, (start || 0) * 2);\n  } else {\n    // TODO need a better way to calculate size..\n    gl.drawArrays(type, start, size || this.getSize());\n  }\n\n  return this;\n};\n/**\n * Destroy this vao\n */\n\n\nVertexArrayObject.prototype.destroy = function () {\n  // lose references\n  this.gl = null;\n  this.indexBuffer = null;\n  this.attributes = null;\n  this.nativeState = null;\n\n  if (this.nativeVao) {\n    this.nativeVaoExtension.deleteVertexArrayOES(this.nativeVao);\n  }\n\n  this.nativeVaoExtension = null;\n  this.nativeVao = null;\n};\n\nVertexArrayObject.prototype.getSize = function () {\n  var attrib = this.attributes[0];\n  return attrib.buffer.data.length / (attrib.stride / 4 || attrib.attribute.size);\n};","map":null,"metadata":{},"sourceType":"script"}