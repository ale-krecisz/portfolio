{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nexports.calculateScreenSpaceMatrix = calculateScreenSpaceMatrix;\nexports.calculateNormalizedScreenSpaceMatrix = calculateNormalizedScreenSpaceMatrix;\nexports.calculateSpriteMatrix = calculateSpriteMatrix;\n\nvar _math = require('../../../math');\n/**\n * Calculates the mapped matrix\n * @param filterArea {Rectangle} The filter area\n * @param sprite {Sprite} the target sprite\n * @param outputMatrix {Matrix} @alvin\n */\n// TODO playing around here.. this is temporary - (will end up in the shader)\n// this returns a matrix that will normalise map filter cords in the filter to screen space\n\n\nfunction calculateScreenSpaceMatrix(outputMatrix, filterArea, textureSize) {\n  // let worldTransform = sprite.worldTransform.copy(Matrix.TEMP_MATRIX),\n  // let texture = {width:1136, height:700};//sprite._texture.baseTexture;\n  // TODO unwrap?\n  var mappedMatrix = outputMatrix.identity();\n  mappedMatrix.translate(filterArea.x / textureSize.width, filterArea.y / textureSize.height);\n  mappedMatrix.scale(textureSize.width, textureSize.height);\n  return mappedMatrix;\n}\n\nfunction calculateNormalizedScreenSpaceMatrix(outputMatrix, filterArea, textureSize) {\n  var mappedMatrix = outputMatrix.identity();\n  mappedMatrix.translate(filterArea.x / textureSize.width, filterArea.y / textureSize.height);\n  var translateScaleX = textureSize.width / filterArea.width;\n  var translateScaleY = textureSize.height / filterArea.height;\n  mappedMatrix.scale(translateScaleX, translateScaleY);\n  return mappedMatrix;\n} // this will map the filter coord so that a texture can be used based on the transform of a sprite\n\n\nfunction calculateSpriteMatrix(outputMatrix, filterArea, textureSize, sprite) {\n  var worldTransform = sprite.worldTransform.copy(_math.Matrix.TEMP_MATRIX);\n  var texture = sprite._texture.baseTexture; // TODO unwrap?\n\n  var mappedMatrix = outputMatrix.identity(); // scale..\n\n  var ratio = textureSize.height / textureSize.width;\n  mappedMatrix.translate(filterArea.x / textureSize.width, filterArea.y / textureSize.height);\n  mappedMatrix.scale(1, ratio);\n  var translateScaleX = textureSize.width / texture.width;\n  var translateScaleY = textureSize.height / texture.height;\n  worldTransform.tx /= texture.width * translateScaleX; // this...?  free beer for anyone who can explain why this makes sense!\n\n  worldTransform.ty /= texture.width * translateScaleX; // worldTransform.ty /= texture.height * translateScaleY;\n\n  worldTransform.invert();\n  mappedMatrix.prepend(worldTransform); // apply inverse scale..\n\n  mappedMatrix.scale(1, 1 / ratio);\n  mappedMatrix.scale(translateScaleX, translateScaleY);\n  mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n  return mappedMatrix;\n}","map":null,"metadata":{},"sourceType":"script"}