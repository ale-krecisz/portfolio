{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _BaseTexture2 = require('./BaseTexture');\n\nvar _BaseTexture3 = _interopRequireDefault(_BaseTexture2);\n\nvar _utils = require('../utils');\n\nvar _ticker = require('../ticker');\n\nvar _const = require('../const');\n\nvar _determineCrossOrigin = require('../utils/determineCrossOrigin');\n\nvar _determineCrossOrigin2 = _interopRequireDefault(_determineCrossOrigin);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n/**\n * A texture of a [playing] Video.\n *\n * Video base textures mimic PixiJS BaseTexture.from.... method in their creation process.\n *\n * This can be used in several ways, such as:\n *\n * ```js\n * let texture = PIXI.VideoBaseTexture.fromUrl('http://mydomain.com/video.mp4');\n *\n * let texture = PIXI.VideoBaseTexture.fromUrl({ src: 'http://mydomain.com/video.mp4', mime: 'video/mp4' });\n *\n * let texture = PIXI.VideoBaseTexture.fromUrls(['/video.webm', '/video.mp4']);\n *\n * let texture = PIXI.VideoBaseTexture.fromUrls([\n *     { src: '/video.webm', mime: 'video/webm' },\n *     { src: '/video.mp4', mime: 'video/mp4' }\n * ]);\n * ```\n *\n * See the [\"deus\" demo](http://www.goodboydigital.com/pixijs/examples/deus/).\n *\n * @class\n * @extends PIXI.BaseTexture\n * @memberof PIXI\n */\n\n\nvar VideoBaseTexture = function (_BaseTexture) {\n  _inherits(VideoBaseTexture, _BaseTexture);\n  /**\n   * @param {HTMLVideoElement} source - Video source\n   * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values\n   * @param {boolean} [autoPlay=true] - Start playing video as soon as it is loaded\n   */\n\n\n  function VideoBaseTexture(source, scaleMode) {\n    var autoPlay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n    _classCallCheck(this, VideoBaseTexture);\n\n    if (!source) {\n      throw new Error('No video source element specified.');\n    } // hook in here to check if video is already available.\n    // BaseTexture looks for a source.complete boolean, plus width & height.\n\n\n    if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height) {\n      source.complete = true;\n    }\n\n    var _this = _possibleConstructorReturn(this, _BaseTexture.call(this, source, scaleMode));\n\n    _this.width = source.videoWidth;\n    _this.height = source.videoHeight;\n    _this._autoUpdate = true;\n    _this._isAutoUpdating = false;\n    /**\n     * When set to true will automatically play videos used by this texture once\n     * they are loaded. If false, it will not modify the playing state.\n     *\n     * @member {boolean}\n     * @default true\n     */\n\n    _this.autoPlay = autoPlay;\n    _this.update = _this.update.bind(_this);\n    _this._onCanPlay = _this._onCanPlay.bind(_this);\n    source.addEventListener('play', _this._onPlayStart.bind(_this));\n    source.addEventListener('pause', _this._onPlayStop.bind(_this));\n    _this.hasLoaded = false;\n    _this.__loaded = false;\n\n    if (!_this._isSourceReady()) {\n      source.addEventListener('canplay', _this._onCanPlay);\n      source.addEventListener('canplaythrough', _this._onCanPlay);\n    } else {\n      _this._onCanPlay();\n    }\n\n    return _this;\n  }\n  /**\n   * Returns true if the underlying source is playing.\n   *\n   * @private\n   * @return {boolean} True if playing.\n   */\n\n\n  VideoBaseTexture.prototype._isSourcePlaying = function _isSourcePlaying() {\n    var source = this.source;\n    return source.currentTime > 0 && source.paused === false && source.ended === false && source.readyState > 2;\n  };\n  /**\n   * Returns true if the underlying source is ready for playing.\n   *\n   * @private\n   * @return {boolean} True if ready.\n   */\n\n\n  VideoBaseTexture.prototype._isSourceReady = function _isSourceReady() {\n    return this.source.readyState === 3 || this.source.readyState === 4;\n  };\n  /**\n   * Runs the update loop when the video is ready to play\n   *\n   * @private\n   */\n\n\n  VideoBaseTexture.prototype._onPlayStart = function _onPlayStart() {\n    // Just in case the video has not received its can play even yet..\n    if (!this.hasLoaded) {\n      this._onCanPlay();\n    }\n\n    if (!this._isAutoUpdating && this.autoUpdate) {\n      _ticker.shared.add(this.update, this, _const.UPDATE_PRIORITY.HIGH);\n\n      this._isAutoUpdating = true;\n    }\n  };\n  /**\n   * Fired when a pause event is triggered, stops the update loop\n   *\n   * @private\n   */\n\n\n  VideoBaseTexture.prototype._onPlayStop = function _onPlayStop() {\n    if (this._isAutoUpdating) {\n      _ticker.shared.remove(this.update, this);\n\n      this._isAutoUpdating = false;\n    }\n  };\n  /**\n   * Fired when the video is loaded and ready to play\n   *\n   * @private\n   */\n\n\n  VideoBaseTexture.prototype._onCanPlay = function _onCanPlay() {\n    this.hasLoaded = true;\n\n    if (this.source) {\n      this.source.removeEventListener('canplay', this._onCanPlay);\n      this.source.removeEventListener('canplaythrough', this._onCanPlay);\n      this.width = this.source.videoWidth;\n      this.height = this.source.videoHeight; // prevent multiple loaded dispatches..\n\n      if (!this.__loaded) {\n        this.__loaded = true;\n        this.emit('loaded', this);\n      }\n\n      if (this._isSourcePlaying()) {\n        this._onPlayStart();\n      } else if (this.autoPlay) {\n        this.source.play();\n      }\n    }\n  };\n  /**\n   * Destroys this texture\n   *\n   */\n\n\n  VideoBaseTexture.prototype.destroy = function destroy() {\n    if (this._isAutoUpdating) {\n      _ticker.shared.remove(this.update, this);\n    }\n\n    if (this.source && this.source._pixiId) {\n      _BaseTexture3.default.removeFromCache(this.source._pixiId);\n\n      delete this.source._pixiId;\n      this.source.pause();\n      this.source.src = '';\n      this.source.load();\n    }\n\n    _BaseTexture.prototype.destroy.call(this);\n  };\n  /**\n   * Mimic PixiJS BaseTexture.from.... method.\n   *\n   * @static\n   * @param {HTMLVideoElement} video - Video to create texture from\n   * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values\n   * @param {boolean} [autoPlay=true] - Start playing video as soon as it is loaded\n   * @return {PIXI.VideoBaseTexture} Newly created VideoBaseTexture\n   */\n\n\n  VideoBaseTexture.fromVideo = function fromVideo(video, scaleMode, autoPlay) {\n    if (!video._pixiId) {\n      video._pixiId = 'video_' + (0, _utils.uid)();\n    }\n\n    var baseTexture = _utils.BaseTextureCache[video._pixiId];\n\n    if (!baseTexture) {\n      baseTexture = new VideoBaseTexture(video, scaleMode, autoPlay);\n\n      _BaseTexture3.default.addToCache(baseTexture, video._pixiId);\n    }\n\n    return baseTexture;\n  };\n  /**\n   * Helper function that creates a new BaseTexture based on the given video element.\n   * This BaseTexture can then be used to create a texture\n   *\n   * @static\n   * @param {string|object|string[]|object[]} videoSrc - The URL(s) for the video.\n   * @param {string} [videoSrc.src] - One of the source urls for the video\n   * @param {string} [videoSrc.mime] - The mimetype of the video (e.g. 'video/mp4'). If not specified\n   *  the url's extension will be used as the second part of the mime type.\n   * @param {number} scaleMode - See {@link PIXI.SCALE_MODES} for possible values\n   * @param {boolean} [crossorigin=(auto)] - Should use anonymous CORS? Defaults to true if the URL is not a data-URI.\n   * @param {boolean} [autoPlay=true] - Start playing video as soon as it is loaded\n   * @return {PIXI.VideoBaseTexture} Newly created VideoBaseTexture\n   */\n\n\n  VideoBaseTexture.fromUrl = function fromUrl(videoSrc, scaleMode, crossorigin, autoPlay) {\n    var video = document.createElement('video');\n    video.setAttribute('webkit-playsinline', '');\n    video.setAttribute('playsinline', '');\n    var url = Array.isArray(videoSrc) ? videoSrc[0].src || videoSrc[0] : videoSrc.src || videoSrc;\n\n    if (crossorigin === undefined && url.indexOf('data:') !== 0) {\n      video.crossOrigin = (0, _determineCrossOrigin2.default)(url);\n    } else if (crossorigin) {\n      video.crossOrigin = typeof crossorigin === 'string' ? crossorigin : 'anonymous';\n    } // array of objects or strings\n\n\n    if (Array.isArray(videoSrc)) {\n      for (var i = 0; i < videoSrc.length; ++i) {\n        video.appendChild(createSource(videoSrc[i].src || videoSrc[i], videoSrc[i].mime));\n      }\n    } // single object or string\n    else {\n        video.appendChild(createSource(url, videoSrc.mime));\n      }\n\n    video.load();\n    return VideoBaseTexture.fromVideo(video, scaleMode, autoPlay);\n  };\n  /**\n   * Should the base texture automatically update itself, set to true by default\n   *\n   * @member {boolean}\n   */\n\n\n  _createClass(VideoBaseTexture, [{\n    key: 'autoUpdate',\n    get: function get() {\n      return this._autoUpdate;\n    },\n    set: function set(value) // eslint-disable-line require-jsdoc\n    {\n      if (value !== this._autoUpdate) {\n        this._autoUpdate = value;\n\n        if (!this._autoUpdate && this._isAutoUpdating) {\n          _ticker.shared.remove(this.update, this);\n\n          this._isAutoUpdating = false;\n        } else if (this._autoUpdate && !this._isAutoUpdating) {\n          _ticker.shared.add(this.update, this, _const.UPDATE_PRIORITY.HIGH);\n\n          this._isAutoUpdating = true;\n        }\n      }\n    }\n  }]);\n\n  return VideoBaseTexture;\n}(_BaseTexture3.default);\n\nexports.default = VideoBaseTexture;\nVideoBaseTexture.fromUrls = VideoBaseTexture.fromUrl;\n\nfunction createSource(path, type) {\n  if (!type) {\n    var purePath = path.split('?').shift().toLowerCase();\n    type = 'video/' + purePath.substr(purePath.lastIndexOf('.') + 1);\n  }\n\n  var source = document.createElement('source');\n  source.src = path;\n  source.type = type;\n  return source;\n}","map":null,"metadata":{},"sourceType":"script"}