{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _WebGLManager2 = require('./WebGLManager');\n\nvar _WebGLManager3 = _interopRequireDefault(_WebGLManager2);\n\nvar _RenderTarget = require('../utils/RenderTarget');\n\nvar _RenderTarget2 = _interopRequireDefault(_RenderTarget);\n\nvar _Quad = require('../utils/Quad');\n\nvar _Quad2 = _interopRequireDefault(_Quad);\n\nvar _math = require('../../../math');\n\nvar _Shader = require('../../../Shader');\n\nvar _Shader2 = _interopRequireDefault(_Shader);\n\nvar _filterTransforms = require('../filters/filterTransforms');\n\nvar filterTransforms = _interopRequireWildcard(_filterTransforms);\n\nvar _bitTwiddle = require('bit-twiddle');\n\nvar _bitTwiddle2 = _interopRequireDefault(_bitTwiddle);\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n/**\n * @ignore\n * @class\n */\n\n\nvar FilterState = function () {\n  /**\n   *\n   */\n  function FilterState() {\n    _classCallCheck(this, FilterState);\n\n    this.renderTarget = null;\n    this.target = null;\n    this.resolution = 1; // those three objects are used only for root\n    // re-assigned for everything else\n\n    this.sourceFrame = new _math.Rectangle();\n    this.destinationFrame = new _math.Rectangle();\n    this.filters = [];\n  }\n  /**\n   * clears the state\n   */\n\n\n  FilterState.prototype.clear = function clear() {\n    this.filters = null;\n    this.target = null;\n    this.renderTarget = null;\n  };\n\n  return FilterState;\n}();\n\nvar screenKey = 'screen';\n/**\n * @class\n * @memberof PIXI\n * @extends PIXI.WebGLManager\n */\n\nvar FilterManager = function (_WebGLManager) {\n  _inherits(FilterManager, _WebGLManager);\n  /**\n   * @param {PIXI.WebGLRenderer} renderer - The renderer this manager works for.\n   */\n\n\n  function FilterManager(renderer) {\n    _classCallCheck(this, FilterManager);\n\n    var _this = _possibleConstructorReturn(this, _WebGLManager.call(this, renderer));\n\n    _this.gl = _this.renderer.gl; // know about sprites!\n\n    _this.quad = new _Quad2.default(_this.gl, renderer.state.attribState);\n    _this.shaderCache = {}; // todo add default!\n\n    _this.pool = {};\n    _this.filterData = null;\n    _this.managedFilters = [];\n\n    _this.renderer.on('prerender', _this.onPrerender, _this);\n\n    _this._screenWidth = renderer.view.width;\n    _this._screenHeight = renderer.view.height;\n    return _this;\n  }\n  /**\n   * Adds a new filter to the manager.\n   *\n   * @param {PIXI.DisplayObject} target - The target of the filter to render.\n   * @param {PIXI.Filter[]} filters - The filters to apply.\n   */\n\n\n  FilterManager.prototype.pushFilter = function pushFilter(target, filters) {\n    var renderer = this.renderer;\n    var filterData = this.filterData;\n\n    if (!filterData) {\n      filterData = this.renderer._activeRenderTarget.filterStack; // add new stack\n\n      var filterState = new FilterState();\n      filterState.sourceFrame = filterState.destinationFrame = this.renderer._activeRenderTarget.size;\n      filterState.renderTarget = renderer._activeRenderTarget;\n      this.renderer._activeRenderTarget.filterData = filterData = {\n        index: 0,\n        stack: [filterState]\n      };\n      this.filterData = filterData;\n    } // get the current filter state..\n\n\n    var currentState = filterData.stack[++filterData.index];\n    var renderTargetFrame = filterData.stack[0].destinationFrame;\n\n    if (!currentState) {\n      currentState = filterData.stack[filterData.index] = new FilterState();\n    }\n\n    var fullScreen = target.filterArea && target.filterArea.x === 0 && target.filterArea.y === 0 && target.filterArea.width === renderer.screen.width && target.filterArea.height === renderer.screen.height; // for now we go off the filter of the first resolution..\n\n    var resolution = filters[0].resolution;\n    var padding = filters[0].padding | 0;\n    var targetBounds = fullScreen ? renderer.screen : target.filterArea || target.getBounds(true);\n    var sourceFrame = currentState.sourceFrame;\n    var destinationFrame = currentState.destinationFrame;\n    sourceFrame.x = (targetBounds.x * resolution | 0) / resolution;\n    sourceFrame.y = (targetBounds.y * resolution | 0) / resolution;\n    sourceFrame.width = (targetBounds.width * resolution | 0) / resolution;\n    sourceFrame.height = (targetBounds.height * resolution | 0) / resolution;\n\n    if (!fullScreen) {\n      if (filterData.stack[0].renderTarget.transform) {//\n        // TODO we should fit the rect around the transform..\n      } else if (filters[0].autoFit) {\n        sourceFrame.fit(renderTargetFrame);\n      } // lets apply the padding After we fit the element to the screen.\n      // this should stop the strange side effects that can occur when cropping to the edges\n\n\n      sourceFrame.pad(padding);\n    }\n\n    destinationFrame.width = sourceFrame.width;\n    destinationFrame.height = sourceFrame.height; // lets play the padding after we fit the element to the screen.\n    // this should stop the strange side effects that can occur when cropping to the edges\n\n    var renderTarget = this.getPotRenderTarget(renderer.gl, sourceFrame.width, sourceFrame.height, resolution);\n    currentState.target = target;\n    currentState.filters = filters;\n    currentState.resolution = resolution;\n    currentState.renderTarget = renderTarget; // bind the render target to draw the shape in the top corner..\n\n    renderTarget.setFrame(destinationFrame, sourceFrame); // bind the render target\n\n    renderer.bindRenderTarget(renderTarget);\n    renderTarget.clear();\n  };\n  /**\n   * Pops off the filter and applies it.\n   *\n   */\n\n\n  FilterManager.prototype.popFilter = function popFilter() {\n    var filterData = this.filterData;\n    var lastState = filterData.stack[filterData.index - 1];\n    var currentState = filterData.stack[filterData.index];\n    this.quad.map(currentState.renderTarget.size, currentState.sourceFrame).upload();\n    var filters = currentState.filters;\n\n    if (filters.length === 1) {\n      filters[0].apply(this, currentState.renderTarget, lastState.renderTarget, false, currentState);\n      this.freePotRenderTarget(currentState.renderTarget);\n    } else {\n      var flip = currentState.renderTarget;\n      var flop = this.getPotRenderTarget(this.renderer.gl, currentState.sourceFrame.width, currentState.sourceFrame.height, currentState.resolution);\n      flop.setFrame(currentState.destinationFrame, currentState.sourceFrame); // finally lets clear the render target before drawing to it..\n\n      flop.clear();\n      var i = 0;\n\n      for (i = 0; i < filters.length - 1; ++i) {\n        filters[i].apply(this, flip, flop, true, currentState);\n        var t = flip;\n        flip = flop;\n        flop = t;\n      }\n\n      filters[i].apply(this, flip, lastState.renderTarget, false, currentState);\n      this.freePotRenderTarget(flip);\n      this.freePotRenderTarget(flop);\n    }\n\n    currentState.clear();\n    filterData.index--;\n\n    if (filterData.index === 0) {\n      this.filterData = null;\n    }\n  };\n  /**\n   * Draws a filter.\n   *\n   * @param {PIXI.Filter} filter - The filter to draw.\n   * @param {PIXI.RenderTarget} input - The input render target.\n   * @param {PIXI.RenderTarget} output - The target to output to.\n   * @param {boolean} clear - Should the output be cleared before rendering to it\n   */\n\n\n  FilterManager.prototype.applyFilter = function applyFilter(filter, input, output, clear) {\n    var renderer = this.renderer;\n    var gl = renderer.gl;\n    var shader = filter.glShaders[renderer.CONTEXT_UID]; // caching..\n\n    if (!shader) {\n      if (filter.glShaderKey) {\n        shader = this.shaderCache[filter.glShaderKey];\n\n        if (!shader) {\n          shader = new _Shader2.default(this.gl, filter.vertexSrc, filter.fragmentSrc);\n          filter.glShaders[renderer.CONTEXT_UID] = this.shaderCache[filter.glShaderKey] = shader;\n          this.managedFilters.push(filter);\n        }\n      } else {\n        shader = filter.glShaders[renderer.CONTEXT_UID] = new _Shader2.default(this.gl, filter.vertexSrc, filter.fragmentSrc);\n        this.managedFilters.push(filter);\n      } // TODO - this only needs to be done once?\n\n\n      renderer.bindVao(null);\n      this.quad.initVao(shader);\n    }\n\n    renderer.bindVao(this.quad.vao);\n    renderer.bindRenderTarget(output);\n\n    if (clear) {\n      gl.disable(gl.SCISSOR_TEST);\n      renderer.clear(); // [1, 1, 1, 1]);\n\n      gl.enable(gl.SCISSOR_TEST);\n    } // in case the render target is being masked using a scissor rect\n\n\n    if (output === renderer.maskManager.scissorRenderTarget) {\n      renderer.maskManager.pushScissorMask(null, renderer.maskManager.scissorData);\n    }\n\n    renderer.bindShader(shader); // free unit 0 for us, doesn't matter what was there\n    // don't try to restore it, because syncUniforms can upload it to another slot\n    // and it'll be a problem\n\n    var tex = this.renderer.emptyTextures[0];\n    this.renderer.boundTextures[0] = tex; // this syncs the PixiJS filters  uniforms with glsl uniforms\n\n    this.syncUniforms(shader, filter);\n    renderer.state.setBlendMode(filter.blendMode);\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, input.texture.texture);\n    this.quad.vao.draw(this.renderer.gl.TRIANGLES, 6, 0);\n    gl.bindTexture(gl.TEXTURE_2D, tex._glTextures[this.renderer.CONTEXT_UID].texture);\n  };\n  /**\n   * Uploads the uniforms of the filter.\n   *\n   * @param {GLShader} shader - The underlying gl shader.\n   * @param {PIXI.Filter} filter - The filter we are synchronizing.\n   */\n\n\n  FilterManager.prototype.syncUniforms = function syncUniforms(shader, filter) {\n    var uniformData = filter.uniformData;\n    var uniforms = filter.uniforms; // 0 is reserved for the PixiJS texture so we start at 1!\n\n    var textureCount = 1;\n    var currentState = void 0; // filterArea and filterClamp that are handled by FilterManager directly\n    // they must not appear in uniformData\n\n    if (shader.uniforms.filterArea) {\n      currentState = this.filterData.stack[this.filterData.index];\n      var filterArea = shader.uniforms.filterArea;\n      filterArea[0] = currentState.renderTarget.size.width;\n      filterArea[1] = currentState.renderTarget.size.height;\n      filterArea[2] = currentState.sourceFrame.x;\n      filterArea[3] = currentState.sourceFrame.y;\n      shader.uniforms.filterArea = filterArea;\n    } // use this to clamp displaced texture coords so they belong to filterArea\n    // see displacementFilter fragment shader for an example\n\n\n    if (shader.uniforms.filterClamp) {\n      currentState = currentState || this.filterData.stack[this.filterData.index];\n      var filterClamp = shader.uniforms.filterClamp;\n      filterClamp[0] = 0;\n      filterClamp[1] = 0;\n      filterClamp[2] = (currentState.sourceFrame.width - 1) / currentState.renderTarget.size.width;\n      filterClamp[3] = (currentState.sourceFrame.height - 1) / currentState.renderTarget.size.height;\n      shader.uniforms.filterClamp = filterClamp;\n    } // TODO Caching layer..\n\n\n    for (var i in uniformData) {\n      if (!shader.uniforms.data[i]) {\n        continue;\n      }\n\n      var type = uniformData[i].type;\n\n      if (type === 'sampler2d' && uniforms[i] !== 0) {\n        if (uniforms[i].baseTexture) {\n          shader.uniforms[i] = this.renderer.bindTexture(uniforms[i].baseTexture, textureCount);\n        } else {\n          shader.uniforms[i] = textureCount; // TODO\n          // this is helpful as renderTargets can also be set.\n          // Although thinking about it, we could probably\n          // make the filter texture cache return a RenderTexture\n          // rather than a renderTarget\n\n          var gl = this.renderer.gl;\n          this.renderer.boundTextures[textureCount] = this.renderer.emptyTextures[textureCount];\n          gl.activeTexture(gl.TEXTURE0 + textureCount);\n          uniforms[i].texture.bind();\n        }\n\n        textureCount++;\n      } else if (type === 'mat3') {\n        // check if its PixiJS matrix..\n        if (uniforms[i].a !== undefined) {\n          shader.uniforms[i] = uniforms[i].toArray(true);\n        } else {\n          shader.uniforms[i] = uniforms[i];\n        }\n      } else if (type === 'vec2') {\n        // check if its a point..\n        if (uniforms[i].x !== undefined) {\n          var val = shader.uniforms[i] || new Float32Array(2);\n          val[0] = uniforms[i].x;\n          val[1] = uniforms[i].y;\n          shader.uniforms[i] = val;\n        } else {\n          shader.uniforms[i] = uniforms[i];\n        }\n      } else if (type === 'float') {\n        if (shader.uniforms.data[i].value !== uniformData[i]) {\n          shader.uniforms[i] = uniforms[i];\n        }\n      } else {\n        shader.uniforms[i] = uniforms[i];\n      }\n    }\n  };\n  /**\n   * Gets a render target from the pool, or creates a new one.\n   *\n   * @param {boolean} clear - Should we clear the render texture when we get it?\n   * @param {number} resolution - The resolution of the target.\n   * @return {PIXI.RenderTarget} The new render target\n   */\n\n\n  FilterManager.prototype.getRenderTarget = function getRenderTarget(clear, resolution) {\n    var currentState = this.filterData.stack[this.filterData.index];\n    var renderTarget = this.getPotRenderTarget(this.renderer.gl, currentState.sourceFrame.width, currentState.sourceFrame.height, resolution || currentState.resolution);\n    renderTarget.setFrame(currentState.destinationFrame, currentState.sourceFrame);\n    return renderTarget;\n  };\n  /**\n   * Returns a render target to the pool.\n   *\n   * @param {PIXI.RenderTarget} renderTarget - The render target to return.\n   */\n\n\n  FilterManager.prototype.returnRenderTarget = function returnRenderTarget(renderTarget) {\n    this.freePotRenderTarget(renderTarget);\n  };\n  /**\n   * Calculates the mapped matrix.\n   *\n   * TODO playing around here.. this is temporary - (will end up in the shader)\n   * this returns a matrix that will normalise map filter cords in the filter to screen space\n   *\n   * @param {PIXI.Matrix} outputMatrix - the matrix to output to.\n   * @return {PIXI.Matrix} The mapped matrix.\n   */\n\n\n  FilterManager.prototype.calculateScreenSpaceMatrix = function calculateScreenSpaceMatrix(outputMatrix) {\n    var currentState = this.filterData.stack[this.filterData.index];\n    return filterTransforms.calculateScreenSpaceMatrix(outputMatrix, currentState.sourceFrame, currentState.renderTarget.size);\n  };\n  /**\n   * Multiply vTextureCoord to this matrix to achieve (0,0,1,1) for filterArea\n   *\n   * @param {PIXI.Matrix} outputMatrix - The matrix to output to.\n   * @return {PIXI.Matrix} The mapped matrix.\n   */\n\n\n  FilterManager.prototype.calculateNormalizedScreenSpaceMatrix = function calculateNormalizedScreenSpaceMatrix(outputMatrix) {\n    var currentState = this.filterData.stack[this.filterData.index];\n    return filterTransforms.calculateNormalizedScreenSpaceMatrix(outputMatrix, currentState.sourceFrame, currentState.renderTarget.size, currentState.destinationFrame);\n  };\n  /**\n   * This will map the filter coord so that a texture can be used based on the transform of a sprite\n   *\n   * @param {PIXI.Matrix} outputMatrix - The matrix to output to.\n   * @param {PIXI.Sprite} sprite - The sprite to map to.\n   * @return {PIXI.Matrix} The mapped matrix.\n   */\n\n\n  FilterManager.prototype.calculateSpriteMatrix = function calculateSpriteMatrix(outputMatrix, sprite) {\n    var currentState = this.filterData.stack[this.filterData.index];\n    return filterTransforms.calculateSpriteMatrix(outputMatrix, currentState.sourceFrame, currentState.renderTarget.size, sprite);\n  };\n  /**\n   * Destroys this Filter Manager.\n   *\n   * @param {boolean} [contextLost=false] context was lost, do not free shaders\n   *\n   */\n\n\n  FilterManager.prototype.destroy = function destroy() {\n    var contextLost = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var renderer = this.renderer;\n    var filters = this.managedFilters;\n    renderer.off('prerender', this.onPrerender, this);\n\n    for (var i = 0; i < filters.length; i++) {\n      if (!contextLost) {\n        filters[i].glShaders[renderer.CONTEXT_UID].destroy();\n      }\n\n      delete filters[i].glShaders[renderer.CONTEXT_UID];\n    }\n\n    this.shaderCache = {};\n\n    if (!contextLost) {\n      this.emptyPool();\n    } else {\n      this.pool = {};\n    }\n  };\n  /**\n   * Gets a Power-of-Two render texture.\n   *\n   * TODO move to a separate class could be on renderer?\n   * also - could cause issue with multiple contexts?\n   *\n   * @private\n   * @param {WebGLRenderingContext} gl - The webgl rendering context\n   * @param {number} minWidth - The minimum width of the render target.\n   * @param {number} minHeight - The minimum height of the render target.\n   * @param {number} resolution - The resolution of the render target.\n   * @return {PIXI.RenderTarget} The new render target.\n   */\n\n\n  FilterManager.prototype.getPotRenderTarget = function getPotRenderTarget(gl, minWidth, minHeight, resolution) {\n    var key = screenKey;\n    minWidth *= resolution;\n    minHeight *= resolution;\n\n    if (minWidth !== this._screenWidth || minHeight !== this._screenHeight) {\n      // TODO you could return a bigger texture if there is not one in the pool?\n      minWidth = _bitTwiddle2.default.nextPow2(minWidth);\n      minHeight = _bitTwiddle2.default.nextPow2(minHeight);\n      key = (minWidth & 0xFFFF) << 16 | minHeight & 0xFFFF;\n    }\n\n    if (!this.pool[key]) {\n      this.pool[key] = [];\n    }\n\n    var renderTarget = this.pool[key].pop(); // creating render target will cause texture to be bound!\n\n    if (!renderTarget) {\n      // temporary bypass cache..\n      var tex = this.renderer.boundTextures[0];\n      gl.activeTexture(gl.TEXTURE0); // internally - this will cause a texture to be bound..\n\n      renderTarget = new _RenderTarget2.default(gl, minWidth, minHeight, null, 1); // set the current one back\n\n      gl.bindTexture(gl.TEXTURE_2D, tex._glTextures[this.renderer.CONTEXT_UID].texture);\n    } // manually tweak the resolution...\n    // this will not modify the size of the frame buffer, just its resolution.\n\n\n    renderTarget.resolution = resolution;\n    renderTarget.defaultFrame.width = renderTarget.size.width = minWidth / resolution;\n    renderTarget.defaultFrame.height = renderTarget.size.height = minHeight / resolution;\n    renderTarget.filterPoolKey = key;\n    return renderTarget;\n  };\n  /**\n   * Empties the texture pool.\n   *\n   */\n\n\n  FilterManager.prototype.emptyPool = function emptyPool() {\n    for (var i in this.pool) {\n      var textures = this.pool[i];\n\n      if (textures) {\n        for (var j = 0; j < textures.length; j++) {\n          textures[j].destroy(true);\n        }\n      }\n    }\n\n    this.pool = {};\n  };\n  /**\n   * Frees a render target back into the pool.\n   *\n   * @param {PIXI.RenderTarget} renderTarget - The renderTarget to free\n   */\n\n\n  FilterManager.prototype.freePotRenderTarget = function freePotRenderTarget(renderTarget) {\n    this.pool[renderTarget.filterPoolKey].push(renderTarget);\n  };\n  /**\n   * Called before the renderer starts rendering.\n   *\n   */\n\n\n  FilterManager.prototype.onPrerender = function onPrerender() {\n    if (this._screenWidth !== this.renderer.view.width || this._screenHeight !== this.renderer.view.height) {\n      this._screenWidth = this.renderer.view.width;\n      this._screenHeight = this.renderer.view.height;\n      var textures = this.pool[screenKey];\n\n      if (textures) {\n        for (var j = 0; j < textures.length; j++) {\n          textures[j].destroy(true);\n        }\n      }\n\n      this.pool[screenKey] = [];\n    }\n  };\n\n  return FilterManager;\n}(_WebGLManager3.default);\n\nexports.default = FilterManager;","map":null,"metadata":{},"sourceType":"script"}