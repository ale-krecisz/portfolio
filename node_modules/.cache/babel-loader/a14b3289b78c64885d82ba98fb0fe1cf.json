{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _utils = require('../../utils');\n\nvar _canUseNewCanvasBlendModes = require('../../renderers/canvas/utils/canUseNewCanvasBlendModes');\n\nvar _canUseNewCanvasBlendModes2 = _interopRequireDefault(_canUseNewCanvasBlendModes);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Utility methods for Sprite/Texture tinting.\n *\n * @class\n * @memberof PIXI\n */\n\n\nvar CanvasTinter = {\n  /**\n   * Basically this method just needs a sprite and a color and tints the sprite with the given color.\n   *\n   * @memberof PIXI.CanvasTinter\n   * @param {PIXI.Sprite} sprite - the sprite to tint\n   * @param {number} color - the color to use to tint the sprite with\n   * @return {HTMLCanvasElement} The tinted canvas\n   */\n  getTintedTexture: function getTintedTexture(sprite, color) {\n    var texture = sprite._texture;\n    color = CanvasTinter.roundColor(color);\n    var stringColor = '#' + ('00000' + (color | 0).toString(16)).substr(-6);\n    texture.tintCache = texture.tintCache || {};\n    var cachedTexture = texture.tintCache[stringColor];\n    var canvas = void 0;\n\n    if (cachedTexture) {\n      if (cachedTexture.tintId === texture._updateID) {\n        return texture.tintCache[stringColor];\n      }\n\n      canvas = texture.tintCache[stringColor];\n    } else {\n      canvas = CanvasTinter.canvas || document.createElement('canvas');\n    }\n\n    CanvasTinter.tintMethod(texture, color, canvas);\n    canvas.tintId = texture._updateID;\n\n    if (CanvasTinter.convertTintToImage) {\n      // is this better?\n      var tintImage = new Image();\n      tintImage.src = canvas.toDataURL();\n      texture.tintCache[stringColor] = tintImage;\n    } else {\n      texture.tintCache[stringColor] = canvas; // if we are not converting the texture to an image then we need to lose the reference to the canvas\n\n      CanvasTinter.canvas = null;\n    }\n\n    return canvas;\n  },\n\n  /**\n   * Tint a texture using the 'multiply' operation.\n   *\n   * @memberof PIXI.CanvasTinter\n   * @param {PIXI.Texture} texture - the texture to tint\n   * @param {number} color - the color to use to tint the sprite with\n   * @param {HTMLCanvasElement} canvas - the current canvas\n   */\n  tintWithMultiply: function tintWithMultiply(texture, color, canvas) {\n    var context = canvas.getContext('2d');\n\n    var crop = texture._frame.clone();\n\n    var resolution = texture.baseTexture.resolution;\n    crop.x *= resolution;\n    crop.y *= resolution;\n    crop.width *= resolution;\n    crop.height *= resolution;\n    canvas.width = Math.ceil(crop.width);\n    canvas.height = Math.ceil(crop.height);\n    context.save();\n    context.fillStyle = '#' + ('00000' + (color | 0).toString(16)).substr(-6);\n    context.fillRect(0, 0, crop.width, crop.height);\n    context.globalCompositeOperation = 'multiply';\n    context.drawImage(texture.baseTexture.source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);\n    context.globalCompositeOperation = 'destination-atop';\n    context.drawImage(texture.baseTexture.source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);\n    context.restore();\n  },\n\n  /**\n   * Tint a texture using the 'overlay' operation.\n   *\n   * @memberof PIXI.CanvasTinter\n   * @param {PIXI.Texture} texture - the texture to tint\n   * @param {number} color - the color to use to tint the sprite with\n   * @param {HTMLCanvasElement} canvas - the current canvas\n   */\n  tintWithOverlay: function tintWithOverlay(texture, color, canvas) {\n    var context = canvas.getContext('2d');\n\n    var crop = texture._frame.clone();\n\n    var resolution = texture.baseTexture.resolution;\n    crop.x *= resolution;\n    crop.y *= resolution;\n    crop.width *= resolution;\n    crop.height *= resolution;\n    canvas.width = Math.ceil(crop.width);\n    canvas.height = Math.ceil(crop.height);\n    context.save();\n    context.globalCompositeOperation = 'copy';\n    context.fillStyle = '#' + ('00000' + (color | 0).toString(16)).substr(-6);\n    context.fillRect(0, 0, crop.width, crop.height);\n    context.globalCompositeOperation = 'destination-atop';\n    context.drawImage(texture.baseTexture.source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height); // context.globalCompositeOperation = 'copy';\n\n    context.restore();\n  },\n\n  /**\n   * Tint a texture pixel per pixel.\n   *\n   * @memberof PIXI.CanvasTinter\n   * @param {PIXI.Texture} texture - the texture to tint\n   * @param {number} color - the color to use to tint the sprite with\n   * @param {HTMLCanvasElement} canvas - the current canvas\n   */\n  tintWithPerPixel: function tintWithPerPixel(texture, color, canvas) {\n    var context = canvas.getContext('2d');\n\n    var crop = texture._frame.clone();\n\n    var resolution = texture.baseTexture.resolution;\n    crop.x *= resolution;\n    crop.y *= resolution;\n    crop.width *= resolution;\n    crop.height *= resolution;\n    canvas.width = Math.ceil(crop.width);\n    canvas.height = Math.ceil(crop.height);\n    context.save();\n    context.globalCompositeOperation = 'copy';\n    context.drawImage(texture.baseTexture.source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);\n    context.restore();\n    var rgbValues = (0, _utils.hex2rgb)(color);\n    var r = rgbValues[0];\n    var g = rgbValues[1];\n    var b = rgbValues[2];\n    var pixelData = context.getImageData(0, 0, crop.width, crop.height);\n    var pixels = pixelData.data;\n\n    for (var i = 0; i < pixels.length; i += 4) {\n      pixels[i + 0] *= r;\n      pixels[i + 1] *= g;\n      pixels[i + 2] *= b;\n    }\n\n    context.putImageData(pixelData, 0, 0);\n  },\n\n  /**\n   * Rounds the specified color according to the CanvasTinter.cacheStepsPerColorChannel.\n   *\n   * @memberof PIXI.CanvasTinter\n   * @param {number} color - the color to round, should be a hex color\n   * @return {number} The rounded color.\n   */\n  roundColor: function roundColor(color) {\n    var step = CanvasTinter.cacheStepsPerColorChannel;\n    var rgbValues = (0, _utils.hex2rgb)(color);\n    rgbValues[0] = Math.min(255, rgbValues[0] / step * step);\n    rgbValues[1] = Math.min(255, rgbValues[1] / step * step);\n    rgbValues[2] = Math.min(255, rgbValues[2] / step * step);\n    return (0, _utils.rgb2hex)(rgbValues);\n  },\n\n  /**\n   * Number of steps which will be used as a cap when rounding colors.\n   *\n   * @memberof PIXI.CanvasTinter\n   * @type {number}\n   */\n  cacheStepsPerColorChannel: 8,\n\n  /**\n   * Tint cache boolean flag.\n   *\n   * @memberof PIXI.CanvasTinter\n   * @type {boolean}\n   */\n  convertTintToImage: false,\n\n  /**\n   * Whether or not the Canvas BlendModes are supported, consequently the ability to tint using the multiply method.\n   *\n   * @memberof PIXI.CanvasTinter\n   * @type {boolean}\n   */\n  canUseMultiply: (0, _canUseNewCanvasBlendModes2.default)(),\n\n  /**\n   * The tinting method that will be used.\n   *\n   * @memberof PIXI.CanvasTinter\n   * @type {tintMethodFunctionType}\n   */\n  tintMethod: 0\n};\nCanvasTinter.tintMethod = CanvasTinter.canUseMultiply ? CanvasTinter.tintWithMultiply : CanvasTinter.tintWithPerPixel;\n/**\n * The tintMethod type.\n *\n * @memberof PIXI.CanvasTinter\n * @callback tintMethodFunctionType\n * @param texture {PIXI.Texture} the texture to tint\n * @param color {number} the color to use to tint the sprite with\n * @param canvas {HTMLCanvasElement} the current canvas\n */\n\nexports.default = CanvasTinter;","map":null,"metadata":{},"sourceType":"script"}