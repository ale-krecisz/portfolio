{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nexports.default = buildPoly;\n\nvar _buildLine = require('./buildLine');\n\nvar _buildLine2 = _interopRequireDefault(_buildLine);\n\nvar _utils = require('../../../utils');\n\nvar _earcut = require('earcut');\n\nvar _earcut2 = _interopRequireDefault(_earcut);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Builds a polygon to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {object} webGLData - an object containing all the webGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the webGL-specific information to create nativeLines\n */\n\n\nfunction buildPoly(graphicsData, webGLData, webGLDataNativeLines) {\n  graphicsData.points = graphicsData.shape.points.slice();\n  var points = graphicsData.points;\n\n  if (graphicsData.fill && points.length >= 6) {\n    var holeArray = []; // Process holes..\n\n    var holes = graphicsData.holes;\n\n    for (var i = 0; i < holes.length; i++) {\n      var hole = holes[i];\n      holeArray.push(points.length / 2);\n      points = points.concat(hole.points);\n    } // get first and last point.. figure out the middle!\n\n\n    var verts = webGLData.points;\n    var indices = webGLData.indices;\n    var length = points.length / 2; // sort color\n\n    var color = (0, _utils.hex2rgb)(graphicsData.fillColor);\n    var alpha = graphicsData.fillAlpha;\n    var r = color[0] * alpha;\n    var g = color[1] * alpha;\n    var b = color[2] * alpha;\n    var triangles = (0, _earcut2.default)(points, holeArray, 2);\n\n    if (!triangles) {\n      return;\n    }\n\n    var vertPos = verts.length / 6;\n\n    for (var _i = 0; _i < triangles.length; _i += 3) {\n      indices.push(triangles[_i] + vertPos);\n      indices.push(triangles[_i] + vertPos);\n      indices.push(triangles[_i + 1] + vertPos);\n      indices.push(triangles[_i + 2] + vertPos);\n      indices.push(triangles[_i + 2] + vertPos);\n    }\n\n    for (var _i2 = 0; _i2 < length; _i2++) {\n      verts.push(points[_i2 * 2], points[_i2 * 2 + 1], r, g, b, alpha);\n    }\n  }\n\n  if (graphicsData.lineWidth > 0) {\n    (0, _buildLine2.default)(graphicsData, webGLData, webGLDataNativeLines);\n  }\n}","map":null,"metadata":{},"sourceType":"script"}