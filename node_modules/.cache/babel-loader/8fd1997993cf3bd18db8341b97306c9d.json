{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _SystemRenderer2 = require('../SystemRenderer');\n\nvar _SystemRenderer3 = _interopRequireDefault(_SystemRenderer2);\n\nvar _MaskManager = require('./managers/MaskManager');\n\nvar _MaskManager2 = _interopRequireDefault(_MaskManager);\n\nvar _StencilManager = require('./managers/StencilManager');\n\nvar _StencilManager2 = _interopRequireDefault(_StencilManager);\n\nvar _FilterManager = require('./managers/FilterManager');\n\nvar _FilterManager2 = _interopRequireDefault(_FilterManager);\n\nvar _RenderTarget = require('./utils/RenderTarget');\n\nvar _RenderTarget2 = _interopRequireDefault(_RenderTarget);\n\nvar _ObjectRenderer = require('./utils/ObjectRenderer');\n\nvar _ObjectRenderer2 = _interopRequireDefault(_ObjectRenderer);\n\nvar _TextureManager = require('./TextureManager');\n\nvar _TextureManager2 = _interopRequireDefault(_TextureManager);\n\nvar _BaseTexture = require('../../textures/BaseTexture');\n\nvar _BaseTexture2 = _interopRequireDefault(_BaseTexture);\n\nvar _TextureGarbageCollector = require('./TextureGarbageCollector');\n\nvar _TextureGarbageCollector2 = _interopRequireDefault(_TextureGarbageCollector);\n\nvar _WebGLState = require('./WebGLState');\n\nvar _WebGLState2 = _interopRequireDefault(_WebGLState);\n\nvar _mapWebGLDrawModesToPixi = require('./utils/mapWebGLDrawModesToPixi');\n\nvar _mapWebGLDrawModesToPixi2 = _interopRequireDefault(_mapWebGLDrawModesToPixi);\n\nvar _validateContext = require('./utils/validateContext');\n\nvar _validateContext2 = _interopRequireDefault(_validateContext);\n\nvar _utils = require('../../utils');\n\nvar _pixiGlCore = require('pixi-gl-core');\n\nvar _pixiGlCore2 = _interopRequireDefault(_pixiGlCore);\n\nvar _const = require('../../const');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar CONTEXT_UID = 0;\n/**\n * The WebGLRenderer draws the scene and all its content onto a webGL enabled canvas. This renderer\n * should be used for browsers that support webGL. This Render works by automatically managing webGLBatchs.\n * So no need for Sprite Batches or Sprite Clouds.\n * Don't forget to add the view to your DOM or you will not see anything :)\n *\n * @class\n * @memberof PIXI\n * @extends PIXI.SystemRenderer\n */\n\nvar WebGLRenderer = function (_SystemRenderer) {\n  _inherits(WebGLRenderer, _SystemRenderer); // eslint-disable-next-line valid-jsdoc\n\n  /**\n   *\n   * @param {object} [options] - The optional renderer parameters\n   * @param {number} [options.width=800] - the width of the screen\n   * @param {number} [options.height=600] - the height of the screen\n   * @param {HTMLCanvasElement} [options.view] - the canvas to use as a view, optional\n   * @param {boolean} [options.transparent=false] - If the render view is transparent, default false\n   * @param {boolean} [options.autoResize=false] - If the render view is automatically resized, default false\n   * @param {boolean} [options.antialias=false] - sets antialias. If not available natively then FXAA\n   *  antialiasing is used\n   * @param {boolean} [options.forceFXAA=false] - forces FXAA antialiasing to be used over native.\n   *  FXAA is faster, but may not always look as great\n   * @param {number} [options.resolution=1] - The resolution / device pixel ratio of the renderer.\n   *  The resolution of the renderer retina would be 2.\n   * @param {boolean} [options.clearBeforeRender=true] - This sets if the renderer will clear\n   *  the canvas or not before the new render pass. If you wish to set this to false, you *must* set\n   *  preserveDrawingBuffer to `true`.\n   * @param {boolean} [options.preserveDrawingBuffer=false] - enables drawing buffer preservation,\n   *  enable this if you need to call toDataUrl on the webgl context.\n   * @param {boolean} [options.roundPixels=false] - If true Pixi will Math.floor() x/y values when\n   *  rendering, stopping pixel interpolation.\n   * @param {number} [options.backgroundColor=0x000000] - The background color of the rendered area\n   *  (shown if not transparent).\n   * @param {boolean} [options.legacy=false] - If true Pixi will aim to ensure compatibility\n   * with older / less advanced devices. If you experiance unexplained flickering try setting this to true.\n   */\n\n\n  function WebGLRenderer(options, arg2, arg3) {\n    _classCallCheck(this, WebGLRenderer);\n\n    var _this = _possibleConstructorReturn(this, _SystemRenderer.call(this, 'WebGL', options, arg2, arg3));\n\n    _this.legacy = _this.options.legacy;\n\n    if (_this.legacy) {\n      _pixiGlCore2.default.VertexArrayObject.FORCE_NATIVE = true;\n    }\n    /**\n     * The type of this renderer as a standardised const\n     *\n     * @member {number}\n     * @see PIXI.RENDERER_TYPE\n     */\n\n\n    _this.type = _const.RENDERER_TYPE.WEBGL;\n    _this.handleContextLost = _this.handleContextLost.bind(_this);\n    _this.handleContextRestored = _this.handleContextRestored.bind(_this);\n\n    _this.view.addEventListener('webglcontextlost', _this.handleContextLost, false);\n\n    _this.view.addEventListener('webglcontextrestored', _this.handleContextRestored, false);\n    /**\n     * The options passed in to create a new webgl context.\n     *\n     * @member {object}\n     * @private\n     */\n\n\n    _this._contextOptions = {\n      alpha: _this.transparent,\n      antialias: _this.options.antialias,\n      premultipliedAlpha: _this.transparent && _this.transparent !== 'notMultiplied',\n      stencil: true,\n      preserveDrawingBuffer: _this.options.preserveDrawingBuffer\n    };\n    _this._backgroundColorRgba[3] = _this.transparent ? 0 : 1;\n    /**\n     * Manages the masks using the stencil buffer.\n     *\n     * @member {PIXI.MaskManager}\n     */\n\n    _this.maskManager = new _MaskManager2.default(_this);\n    /**\n     * Manages the stencil buffer.\n     *\n     * @member {PIXI.StencilManager}\n     */\n\n    _this.stencilManager = new _StencilManager2.default(_this);\n    /**\n     * An empty renderer.\n     *\n     * @member {PIXI.ObjectRenderer}\n     */\n\n    _this.emptyRenderer = new _ObjectRenderer2.default(_this);\n    /**\n     * The currently active ObjectRenderer.\n     *\n     * @member {PIXI.ObjectRenderer}\n     */\n\n    _this.currentRenderer = _this.emptyRenderer;\n\n    _this.initPlugins();\n    /**\n     * The current WebGL rendering context, it is created here\n     *\n     * @member {WebGLRenderingContext}\n     */\n    // initialize the context so it is ready for the managers.\n\n\n    if (_this.options.context) {\n      // checks to see if a context is valid..\n      (0, _validateContext2.default)(_this.options.context);\n    }\n\n    _this.gl = _this.options.context || _pixiGlCore2.default.createContext(_this.view, _this._contextOptions);\n    _this.CONTEXT_UID = CONTEXT_UID++;\n    /**\n     * The currently active ObjectRenderer.\n     *\n     * @member {PIXI.WebGLState}\n     */\n\n    _this.state = new _WebGLState2.default(_this.gl);\n    _this.renderingToScreen = true;\n    /**\n     * Holds the current state of textures bound to the GPU.\n     * @type {Array}\n     */\n\n    _this.boundTextures = null;\n    /**\n     * Holds the current shader\n     *\n     * @member {PIXI.Shader}\n     */\n\n    _this._activeShader = null;\n    _this._activeVao = null;\n    /**\n     * Holds the current render target\n     *\n     * @member {PIXI.RenderTarget}\n     */\n\n    _this._activeRenderTarget = null;\n\n    _this._initContext();\n    /**\n     * Manages the filters.\n     *\n     * @member {PIXI.FilterManager}\n     */\n\n\n    _this.filterManager = new _FilterManager2.default(_this); // map some webGL blend and drawmodes..\n\n    _this.drawModes = (0, _mapWebGLDrawModesToPixi2.default)(_this.gl);\n    _this._nextTextureLocation = 0;\n\n    _this.setBlendMode(0);\n    /**\n     * Fired after rendering finishes.\n     *\n     * @event PIXI.WebGLRenderer#postrender\n     */\n\n    /**\n     * Fired before rendering starts.\n     *\n     * @event PIXI.WebGLRenderer#prerender\n     */\n\n    /**\n     * Fired when the WebGL context is set.\n     *\n     * @event PIXI.WebGLRenderer#context\n     * @param {WebGLRenderingContext} gl - WebGL context.\n     */\n\n\n    return _this;\n  }\n  /**\n   * Creates the WebGL context\n   *\n   * @private\n   */\n\n\n  WebGLRenderer.prototype._initContext = function _initContext() {\n    var gl = this.gl; // restore a context if it was previously lost\n\n    if (gl.isContextLost() && gl.getExtension('WEBGL_lose_context')) {\n      gl.getExtension('WEBGL_lose_context').restoreContext();\n    }\n\n    var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n    this._activeShader = null;\n    this._activeVao = null;\n    this.boundTextures = new Array(maxTextures);\n    this.emptyTextures = new Array(maxTextures); // create a texture manager...\n\n    this.textureManager = new _TextureManager2.default(this);\n    this.textureGC = new _TextureGarbageCollector2.default(this);\n    this.state.resetToDefault();\n    this.rootRenderTarget = new _RenderTarget2.default(gl, this.width, this.height, null, this.resolution, true);\n    this.rootRenderTarget.clearColor = this._backgroundColorRgba;\n    this.bindRenderTarget(this.rootRenderTarget); // now lets fill up the textures with empty ones!\n\n    var emptyGLTexture = new _pixiGlCore2.default.GLTexture.fromData(gl, null, 1, 1);\n    var tempObj = {\n      _glTextures: {}\n    };\n    tempObj._glTextures[this.CONTEXT_UID] = {};\n\n    for (var i = 0; i < maxTextures; i++) {\n      var empty = new _BaseTexture2.default();\n      empty._glTextures[this.CONTEXT_UID] = emptyGLTexture;\n      this.boundTextures[i] = tempObj;\n      this.emptyTextures[i] = empty;\n      this.bindTexture(null, i);\n    }\n\n    this.emit('context', gl); // setup the width/height properties and gl viewport\n\n    this.resize(this.screen.width, this.screen.height);\n  };\n  /**\n   * Renders the object to its webGL view\n   *\n   * @param {PIXI.DisplayObject} displayObject - the object to be rendered\n   * @param {PIXI.RenderTexture} renderTexture - The render texture to render to.\n   * @param {boolean} [clear] - Should the canvas be cleared before the new render\n   * @param {PIXI.Transform} [transform] - A transform to apply to the render texture before rendering.\n   * @param {boolean} [skipUpdateTransform] - Should we skip the update transform pass?\n   */\n\n\n  WebGLRenderer.prototype.render = function render(displayObject, renderTexture, clear, transform, skipUpdateTransform) {\n    // can be handy to know!\n    this.renderingToScreen = !renderTexture;\n    this.emit('prerender'); // no point rendering if our context has been blown up!\n\n    if (!this.gl || this.gl.isContextLost()) {\n      return;\n    }\n\n    this._nextTextureLocation = 0;\n\n    if (!renderTexture) {\n      this._lastObjectRendered = displayObject;\n    }\n\n    if (!skipUpdateTransform) {\n      // update the scene graph\n      var cacheParent = displayObject.parent;\n      displayObject.parent = this._tempDisplayObjectParent;\n      displayObject.updateTransform();\n      displayObject.parent = cacheParent; // displayObject.hitArea = //TODO add a temp hit area\n    }\n\n    this.bindRenderTexture(renderTexture, transform);\n    this.currentRenderer.start();\n\n    if (clear !== undefined ? clear : this.clearBeforeRender) {\n      this._activeRenderTarget.clear();\n    }\n\n    displayObject.renderWebGL(this); // apply transform..\n\n    this.currentRenderer.flush(); // this.setObjectRenderer(this.emptyRenderer);\n\n    this.textureGC.update();\n    this.emit('postrender');\n  };\n  /**\n   * Changes the current renderer to the one given in parameter\n   *\n   * @param {PIXI.ObjectRenderer} objectRenderer - The object renderer to use.\n   */\n\n\n  WebGLRenderer.prototype.setObjectRenderer = function setObjectRenderer(objectRenderer) {\n    if (this.currentRenderer === objectRenderer) {\n      return;\n    }\n\n    this.currentRenderer.stop();\n    this.currentRenderer = objectRenderer;\n    this.currentRenderer.start();\n  };\n  /**\n   * This should be called if you wish to do some custom rendering\n   * It will basically render anything that may be batched up such as sprites\n   *\n   */\n\n\n  WebGLRenderer.prototype.flush = function flush() {\n    this.setObjectRenderer(this.emptyRenderer);\n  };\n  /**\n   * Resizes the webGL view to the specified width and height.\n   *\n   * @param {number} screenWidth - the new width of the screen\n   * @param {number} screenHeight - the new height of the screen\n   */\n\n\n  WebGLRenderer.prototype.resize = function resize(screenWidth, screenHeight) {\n    //  if(width * this.resolution === this.width && height * this.resolution === this.height)return;\n    _SystemRenderer3.default.prototype.resize.call(this, screenWidth, screenHeight);\n\n    this.rootRenderTarget.resize(screenWidth, screenHeight);\n\n    if (this._activeRenderTarget === this.rootRenderTarget) {\n      this.rootRenderTarget.activate();\n\n      if (this._activeShader) {\n        this._activeShader.uniforms.projectionMatrix = this.rootRenderTarget.projectionMatrix.toArray(true);\n      }\n    }\n  };\n  /**\n   * Resizes the webGL view to the specified width and height.\n   *\n   * @param {number} blendMode - the desired blend mode\n   */\n\n\n  WebGLRenderer.prototype.setBlendMode = function setBlendMode(blendMode) {\n    this.state.setBlendMode(blendMode);\n  };\n  /**\n   * Erases the active render target and fills the drawing area with a colour\n   *\n   * @param {number} [clearColor] - The colour\n   */\n\n\n  WebGLRenderer.prototype.clear = function clear(clearColor) {\n    this._activeRenderTarget.clear(clearColor);\n  };\n  /**\n   * Sets the transform of the active render target to the given matrix\n   *\n   * @param {PIXI.Matrix} matrix - The transformation matrix\n   */\n\n\n  WebGLRenderer.prototype.setTransform = function setTransform(matrix) {\n    this._activeRenderTarget.transform = matrix;\n  };\n  /**\n   * Erases the render texture and fills the drawing area with a colour\n   *\n   * @param {PIXI.RenderTexture} renderTexture - The render texture to clear\n   * @param {number} [clearColor] - The colour\n   * @return {PIXI.WebGLRenderer} Returns itself.\n   */\n\n\n  WebGLRenderer.prototype.clearRenderTexture = function clearRenderTexture(renderTexture, clearColor) {\n    var baseTexture = renderTexture.baseTexture;\n    var renderTarget = baseTexture._glRenderTargets[this.CONTEXT_UID];\n\n    if (renderTarget) {\n      renderTarget.clear(clearColor);\n    }\n\n    return this;\n  };\n  /**\n   * Binds a render texture for rendering\n   *\n   * @param {PIXI.RenderTexture} renderTexture - The render texture to render\n   * @param {PIXI.Transform} transform - The transform to be applied to the render texture\n   * @return {PIXI.WebGLRenderer} Returns itself.\n   */\n\n\n  WebGLRenderer.prototype.bindRenderTexture = function bindRenderTexture(renderTexture, transform) {\n    var renderTarget = void 0;\n\n    if (renderTexture) {\n      var baseTexture = renderTexture.baseTexture;\n\n      if (!baseTexture._glRenderTargets[this.CONTEXT_UID]) {\n        // bind the current texture\n        this.textureManager.updateTexture(baseTexture, 0);\n      }\n\n      this.unbindTexture(baseTexture);\n      renderTarget = baseTexture._glRenderTargets[this.CONTEXT_UID];\n      renderTarget.setFrame(renderTexture.frame);\n    } else {\n      renderTarget = this.rootRenderTarget;\n    }\n\n    renderTarget.transform = transform;\n    this.bindRenderTarget(renderTarget);\n    return this;\n  };\n  /**\n   * Changes the current render target to the one given in parameter\n   *\n   * @param {PIXI.RenderTarget} renderTarget - the new render target\n   * @return {PIXI.WebGLRenderer} Returns itself.\n   */\n\n\n  WebGLRenderer.prototype.bindRenderTarget = function bindRenderTarget(renderTarget) {\n    if (renderTarget !== this._activeRenderTarget) {\n      this._activeRenderTarget = renderTarget;\n      renderTarget.activate();\n\n      if (this._activeShader) {\n        this._activeShader.uniforms.projectionMatrix = renderTarget.projectionMatrix.toArray(true);\n      }\n\n      this.stencilManager.setMaskStack(renderTarget.stencilMaskStack);\n    }\n\n    return this;\n  };\n  /**\n   * Changes the current shader to the one given in parameter\n   *\n   * @param {PIXI.Shader} shader - the new shader\n   * @param {boolean} [autoProject=true] - Whether automatically set the projection matrix\n   * @return {PIXI.WebGLRenderer} Returns itself.\n   */\n\n\n  WebGLRenderer.prototype.bindShader = function bindShader(shader, autoProject) {\n    // TODO cache\n    if (this._activeShader !== shader) {\n      this._activeShader = shader;\n      shader.bind(); // `autoProject` normally would be a default parameter set to true\n      // but because of how Babel transpiles default parameters\n      // it hinders the performance of this method.\n\n      if (autoProject !== false) {\n        // automatically set the projection matrix\n        shader.uniforms.projectionMatrix = this._activeRenderTarget.projectionMatrix.toArray(true);\n      }\n    }\n\n    return this;\n  };\n  /**\n   * Binds the texture. This will return the location of the bound texture.\n   * It may not be the same as the one you pass in. This is due to optimisation that prevents\n   * needless binding of textures. For example if the texture is already bound it will return the\n   * current location of the texture instead of the one provided. To bypass this use force location\n   *\n   * @param {PIXI.Texture} texture - the new texture\n   * @param {number} location - the suggested texture location\n   * @param {boolean} forceLocation - force the location\n   * @return {number} bound texture location\n   */\n\n\n  WebGLRenderer.prototype.bindTexture = function bindTexture(texture, location, forceLocation) {\n    texture = texture || this.emptyTextures[location];\n    texture = texture.baseTexture || texture;\n    texture.touched = this.textureGC.count;\n\n    if (!forceLocation) {\n      // TODO - maybe look into adding boundIds.. save us the loop?\n      for (var i = 0; i < this.boundTextures.length; i++) {\n        if (this.boundTextures[i] === texture) {\n          return i;\n        }\n      }\n\n      if (location === undefined) {\n        this._nextTextureLocation++;\n        this._nextTextureLocation %= this.boundTextures.length;\n        location = this.boundTextures.length - this._nextTextureLocation - 1;\n      }\n    } else {\n      location = location || 0;\n    }\n\n    var gl = this.gl;\n    var glTexture = texture._glTextures[this.CONTEXT_UID];\n\n    if (!glTexture) {\n      // this will also bind the texture..\n      this.textureManager.updateTexture(texture, location);\n    } else {\n      // bind the current texture\n      this.boundTextures[location] = texture;\n      gl.activeTexture(gl.TEXTURE0 + location);\n      gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);\n    }\n\n    return location;\n  };\n  /**\n  * unbinds the texture ...\n  *\n  * @param {PIXI.Texture} texture - the texture to unbind\n  * @return {PIXI.WebGLRenderer} Returns itself.\n  */\n\n\n  WebGLRenderer.prototype.unbindTexture = function unbindTexture(texture) {\n    var gl = this.gl;\n    texture = texture.baseTexture || texture;\n\n    for (var i = 0; i < this.boundTextures.length; i++) {\n      if (this.boundTextures[i] === texture) {\n        this.boundTextures[i] = this.emptyTextures[i];\n        gl.activeTexture(gl.TEXTURE0 + i);\n        gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[i]._glTextures[this.CONTEXT_UID].texture);\n      }\n    }\n\n    return this;\n  };\n  /**\n   * Creates a new VAO from this renderer's context and state.\n   *\n   * @return {VertexArrayObject} The new VAO.\n   */\n\n\n  WebGLRenderer.prototype.createVao = function createVao() {\n    return new _pixiGlCore2.default.VertexArrayObject(this.gl, this.state.attribState);\n  };\n  /**\n   * Changes the current Vao to the one given in parameter\n   *\n   * @param {PIXI.VertexArrayObject} vao - the new Vao\n   * @return {PIXI.WebGLRenderer} Returns itself.\n   */\n\n\n  WebGLRenderer.prototype.bindVao = function bindVao(vao) {\n    if (this._activeVao === vao) {\n      return this;\n    }\n\n    if (vao) {\n      vao.bind();\n    } else if (this._activeVao) {\n      // TODO this should always be true i think?\n      this._activeVao.unbind();\n    }\n\n    this._activeVao = vao;\n    return this;\n  };\n  /**\n   * Resets the WebGL state so you can render things however you fancy!\n   *\n   * @return {PIXI.WebGLRenderer} Returns itself.\n   */\n\n\n  WebGLRenderer.prototype.reset = function reset() {\n    this.setObjectRenderer(this.emptyRenderer);\n    this._activeShader = null;\n    this._activeRenderTarget = this.rootRenderTarget; // bind the main frame buffer (the screen);\n\n    this.rootRenderTarget.activate();\n    this.state.resetToDefault();\n    return this;\n  };\n  /**\n   * Handles a lost webgl context\n   *\n   * @private\n   * @param {WebGLContextEvent} event - The context lost event.\n   */\n\n\n  WebGLRenderer.prototype.handleContextLost = function handleContextLost(event) {\n    event.preventDefault();\n  };\n  /**\n   * Handles a restored webgl context\n   *\n   * @private\n   */\n\n\n  WebGLRenderer.prototype.handleContextRestored = function handleContextRestored() {\n    this.textureManager.removeAll();\n\n    this._initContext();\n  };\n  /**\n   * Removes everything from the renderer (event listeners, spritebatch, etc...)\n   *\n   * @param {boolean} [removeView=false] - Removes the Canvas element from the DOM.\n   *  See: https://github.com/pixijs/pixi.js/issues/2233\n   */\n\n\n  WebGLRenderer.prototype.destroy = function destroy(removeView) {\n    this.destroyPlugins(); // remove listeners\n\n    this.view.removeEventListener('webglcontextlost', this.handleContextLost);\n    this.view.removeEventListener('webglcontextrestored', this.handleContextRestored);\n    this.textureManager.destroy(); // call base destroy\n\n    _SystemRenderer.prototype.destroy.call(this, removeView);\n\n    this.uid = 0; // destroy the managers\n\n    this.maskManager.destroy();\n    this.stencilManager.destroy();\n    this.filterManager.destroy();\n    this.maskManager = null;\n    this.filterManager = null;\n    this.textureManager = null;\n    this.currentRenderer = null;\n    this.handleContextLost = null;\n    this.handleContextRestored = null;\n    this._contextOptions = null;\n    this.gl.useProgram(null);\n\n    if (this.gl.getExtension('WEBGL_lose_context')) {\n      this.gl.getExtension('WEBGL_lose_context').loseContext();\n    }\n\n    this.gl = null; // this = null;\n  };\n\n  return WebGLRenderer;\n}(_SystemRenderer3.default);\n/**\n * Collection of installed plugins. These are included by default in PIXI, but can be excluded\n * by creating a custom build. Consult the README for more information about creating custom\n * builds and excluding plugins.\n * @name PIXI.WebGLRenderer#plugins\n * @type {object}\n * @readonly\n * @property {PIXI.accessibility.AccessibilityManager} accessibility Support tabbing interactive elements.\n * @property {PIXI.extract.WebGLExtract} extract Extract image data from renderer.\n * @property {PIXI.interaction.InteractionManager} interaction Handles mouse, touch and pointer events.\n * @property {PIXI.prepare.WebGLPrepare} prepare Pre-render display objects.\n */\n\n/**\n * Adds a plugin to the renderer.\n *\n * @method PIXI.WebGLRenderer#registerPlugin\n * @param {string} pluginName - The name of the plugin.\n * @param {Function} ctor - The constructor function or class for the plugin.\n */\n\n\nexports.default = WebGLRenderer;\n\n_utils.pluginTarget.mixin(WebGLRenderer);","map":null,"metadata":{},"sourceType":"script"}