{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n/**\n * The TextMetrics object represents the measurement of a block of text with a specified style.\n *\n * @class\n * @memberOf PIXI\n */\n\n\nvar TextMetrics = function () {\n  /**\n   * @param {string} text - the text that was measured\n   * @param {PIXI.TextStyle} style - the style that was measured\n   * @param {number} width - the measured width of the text\n   * @param {number} height - the measured height of the text\n   * @param {array} lines - an array of the lines of text broken by new lines and wrapping if specified in style\n   * @param {array} lineWidths - an array of the line widths for each line matched to `lines`\n   * @param {number} lineHeight - the measured line height for this style\n   * @param {number} maxLineWidth - the maximum line width for all measured lines\n   * @param {Object} fontProperties - the font properties object from TextMetrics.measureFont\n   */\n  function TextMetrics(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {\n    _classCallCheck(this, TextMetrics);\n\n    this.text = text;\n    this.style = style;\n    this.width = width;\n    this.height = height;\n    this.lines = lines;\n    this.lineWidths = lineWidths;\n    this.lineHeight = lineHeight;\n    this.maxLineWidth = maxLineWidth;\n    this.fontProperties = fontProperties;\n  }\n  /**\n   * Measures the supplied string of text and returns a Rectangle.\n   *\n   * @param {string} text - the text to measure.\n   * @param {PIXI.TextStyle} style - the text style to use for measuring\n   * @param {boolean} [wordWrap] - optional override for if word-wrap should be applied to the text.\n   * @param {HTMLCanvasElement} [canvas] - optional specification of the canvas to use for measuring.\n   * @return {PIXI.TextMetrics} measured width and height of the text.\n   */\n\n\n  TextMetrics.measureText = function measureText(text, style, wordWrap) {\n    var canvas = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : TextMetrics._canvas;\n    wordWrap = wordWrap || style.wordWrap;\n    var font = style.toFontString();\n    var fontProperties = TextMetrics.measureFont(font);\n    var context = canvas.getContext('2d');\n    context.font = font;\n    var outputText = wordWrap ? TextMetrics.wordWrap(text, style, canvas) : text;\n    var lines = outputText.split(/(?:\\r\\n|\\r|\\n)/);\n    var lineWidths = new Array(lines.length);\n    var maxLineWidth = 0;\n\n    for (var i = 0; i < lines.length; i++) {\n      var lineWidth = context.measureText(lines[i]).width + (lines[i].length - 1) * style.letterSpacing;\n      lineWidths[i] = lineWidth;\n      maxLineWidth = Math.max(maxLineWidth, lineWidth);\n    }\n\n    var width = maxLineWidth + style.strokeThickness;\n\n    if (style.dropShadow) {\n      width += style.dropShadowDistance;\n    }\n\n    var lineHeight = style.lineHeight || fontProperties.fontSize + style.strokeThickness;\n    var height = Math.max(lineHeight, fontProperties.fontSize + style.strokeThickness) + (lines.length - 1) * lineHeight;\n\n    if (style.dropShadow) {\n      height += style.dropShadowDistance;\n    }\n\n    return new TextMetrics(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties);\n  };\n  /**\n   * Applies newlines to a string to have it optimally fit into the horizontal\n   * bounds set by the Text object's wordWrapWidth property.\n   *\n   * @private\n   * @param {string} text - String to apply word wrapping to\n   * @param {PIXI.TextStyle} style - the style to use when wrapping\n   * @param {HTMLCanvasElement} [canvas] - optional specification of the canvas to use for measuring.\n   * @return {string} New string with new lines applied where required\n   */\n\n\n  TextMetrics.wordWrap = function wordWrap(text, style) {\n    var canvas = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : TextMetrics._canvas;\n    var context = canvas.getContext('2d'); // Greedy wrapping algorithm that will wrap words as the line grows longer\n    // than its horizontal bounds.\n\n    var result = '';\n    var lines = text.split('\\n');\n    var wordWrapWidth = style.wordWrapWidth;\n    var characterCache = {};\n\n    for (var i = 0; i < lines.length; i++) {\n      var spaceLeft = wordWrapWidth;\n      var words = lines[i].split(' ');\n\n      for (var j = 0; j < words.length; j++) {\n        var wordWidth = context.measureText(words[j]).width;\n\n        if (style.breakWords && wordWidth > wordWrapWidth) {\n          // Word should be split in the middle\n          var characters = words[j].split('');\n\n          for (var c = 0; c < characters.length; c++) {\n            var character = characters[c];\n            var characterWidth = characterCache[character];\n\n            if (characterWidth === undefined) {\n              characterWidth = context.measureText(character).width;\n              characterCache[character] = characterWidth;\n            }\n\n            if (characterWidth > spaceLeft) {\n              result += '\\n' + character;\n              spaceLeft = wordWrapWidth - characterWidth;\n            } else {\n              if (c === 0) {\n                result += ' ';\n              }\n\n              result += character;\n              spaceLeft -= characterWidth;\n            }\n          }\n        } else {\n          var wordWidthWithSpace = wordWidth + context.measureText(' ').width;\n\n          if (j === 0 || wordWidthWithSpace > spaceLeft) {\n            // Skip printing the newline if it's the first word of the line that is\n            // greater than the word wrap width.\n            if (j > 0) {\n              result += '\\n';\n            }\n\n            result += words[j];\n            spaceLeft = wordWrapWidth - wordWidth;\n          } else {\n            spaceLeft -= wordWidthWithSpace;\n            result += ' ' + words[j];\n          }\n        }\n      }\n\n      if (i < lines.length - 1) {\n        result += '\\n';\n      }\n    }\n\n    return result;\n  };\n  /**\n   * Calculates the ascent, descent and fontSize of a given font-style\n   *\n   * @static\n   * @param {string} font - String representing the style of the font\n   * @return {PIXI.TextMetrics~FontMetrics} Font properties object\n   */\n\n\n  TextMetrics.measureFont = function measureFont(font) {\n    // as this method is used for preparing assets, don't recalculate things if we don't need to\n    if (TextMetrics._fonts[font]) {\n      return TextMetrics._fonts[font];\n    }\n\n    var properties = {};\n    var canvas = TextMetrics._canvas;\n    var context = TextMetrics._context;\n    context.font = font;\n    var width = Math.ceil(context.measureText('|MÉq').width);\n    var baseline = Math.ceil(context.measureText('M').width);\n    var height = 2 * baseline;\n    baseline = baseline * 1.4 | 0;\n    canvas.width = width;\n    canvas.height = height;\n    context.fillStyle = '#f00';\n    context.fillRect(0, 0, width, height);\n    context.font = font;\n    context.textBaseline = 'alphabetic';\n    context.fillStyle = '#000';\n    context.fillText('|MÉq', 0, baseline);\n    var imagedata = context.getImageData(0, 0, width, height).data;\n    var pixels = imagedata.length;\n    var line = width * 4;\n    var i = 0;\n    var idx = 0;\n    var stop = false; // ascent. scan from top to bottom until we find a non red pixel\n\n    for (i = 0; i < baseline; ++i) {\n      for (var j = 0; j < line; j += 4) {\n        if (imagedata[idx + j] !== 255) {\n          stop = true;\n          break;\n        }\n      }\n\n      if (!stop) {\n        idx += line;\n      } else {\n        break;\n      }\n    }\n\n    properties.ascent = baseline - i;\n    idx = pixels - line;\n    stop = false; // descent. scan from bottom to top until we find a non red pixel\n\n    for (i = height; i > baseline; --i) {\n      for (var _j = 0; _j < line; _j += 4) {\n        if (imagedata[idx + _j] !== 255) {\n          stop = true;\n          break;\n        }\n      }\n\n      if (!stop) {\n        idx -= line;\n      } else {\n        break;\n      }\n    }\n\n    properties.descent = i - baseline;\n    properties.fontSize = properties.ascent + properties.descent;\n    TextMetrics._fonts[font] = properties;\n    return properties;\n  };\n\n  return TextMetrics;\n}();\n/**\n * Internal return object for {@link PIXI.TextMetrics.measureFont `TextMetrics.measureFont`}.\n * @class FontMetrics\n * @memberof PIXI.TextMetrics~\n * @property {number} ascent - The ascent distance\n * @property {number} descent - The descent distance\n * @property {number} fontSize - Font size from ascent to descent\n */\n\n\nexports.default = TextMetrics;\nvar canvas = document.createElement('canvas');\ncanvas.width = canvas.height = 10;\n/**\n * Cached canvas element for measuring text\n * @memberof PIXI.TextMetrics\n * @type {HTMLCanvasElement}\n * @private\n */\n\nTextMetrics._canvas = canvas;\n/**\n * Cache for context to use.\n * @memberof PIXI.TextMetrics\n * @type {CanvasRenderingContext2D}\n * @private\n */\n\nTextMetrics._context = canvas.getContext('2d');\n/**\n * Cache of PIXI.TextMetrics~FontMetrics objects.\n * @memberof PIXI.TextMetrics\n * @type {Object}\n * @private\n */\n\nTextMetrics._fonts = {};","map":null,"metadata":{},"sourceType":"script"}