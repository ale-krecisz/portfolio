{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _utils = require('../utils');\n\nvar _DisplayObject2 = require('./DisplayObject');\n\nvar _DisplayObject3 = _interopRequireDefault(_DisplayObject2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n/**\n * A Container represents a collection of display objects.\n * It is the base class of all display objects that act as a container for other objects.\n *\n *```js\n * let container = new PIXI.Container();\n * container.addChild(sprite);\n * ```\n *\n * @class\n * @extends PIXI.DisplayObject\n * @memberof PIXI\n */\n\n\nvar Container = function (_DisplayObject) {\n  _inherits(Container, _DisplayObject);\n  /**\n   *\n   */\n\n\n  function Container() {\n    _classCallCheck(this, Container);\n    /**\n     * The array of children of this container.\n     *\n     * @member {PIXI.DisplayObject[]}\n     * @readonly\n     */\n\n\n    var _this = _possibleConstructorReturn(this, _DisplayObject.call(this));\n\n    _this.children = [];\n    return _this;\n  }\n  /**\n   * Overridable method that can be used by Container subclasses whenever the children array is modified\n   *\n   * @private\n   */\n\n\n  Container.prototype.onChildrenChange = function onChildrenChange() {}\n  /* empty */\n\n  /**\n   * Adds one or more children to the container.\n   *\n   * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`\n   *\n   * @param {...PIXI.DisplayObject} child - The DisplayObject(s) to add to the container\n   * @return {PIXI.DisplayObject} The first child that was added.\n   */\n  ;\n\n  Container.prototype.addChild = function addChild(child) {\n    var argumentsLength = arguments.length; // if there is only one argument we can bypass looping through the them\n\n    if (argumentsLength > 1) {\n      // loop through the arguments property and add all children\n      // use it the right way (.length and [i]) so that this function can still be optimised by JS runtimes\n      for (var i = 0; i < argumentsLength; i++) {\n        this.addChild(arguments[i]);\n      }\n    } else {\n      // if the child has a parent then lets remove it as Pixi objects can only exist in one place\n      if (child.parent) {\n        child.parent.removeChild(child);\n      }\n\n      child.parent = this; // ensure child transform will be recalculated\n\n      child.transform._parentID = -1;\n      this.children.push(child); // ensure bounds will be recalculated\n\n      this._boundsID++; // TODO - lets either do all callbacks or all events.. not both!\n\n      this.onChildrenChange(this.children.length - 1);\n      child.emit('added', this);\n    }\n\n    return child;\n  };\n  /**\n   * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown\n   *\n   * @param {PIXI.DisplayObject} child - The child to add\n   * @param {number} index - The index to place the child in\n   * @return {PIXI.DisplayObject} The child that was added.\n   */\n\n\n  Container.prototype.addChildAt = function addChildAt(child, index) {\n    if (index < 0 || index > this.children.length) {\n      throw new Error(child + 'addChildAt: The index ' + index + ' supplied is out of bounds ' + this.children.length);\n    }\n\n    if (child.parent) {\n      child.parent.removeChild(child);\n    }\n\n    child.parent = this; // ensure child transform will be recalculated\n\n    child.transform._parentID = -1;\n    this.children.splice(index, 0, child); // ensure bounds will be recalculated\n\n    this._boundsID++; // TODO - lets either do all callbacks or all events.. not both!\n\n    this.onChildrenChange(index);\n    child.emit('added', this);\n    return child;\n  };\n  /**\n   * Swaps the position of 2 Display Objects within this container.\n   *\n   * @param {PIXI.DisplayObject} child - First display object to swap\n   * @param {PIXI.DisplayObject} child2 - Second display object to swap\n   */\n\n\n  Container.prototype.swapChildren = function swapChildren(child, child2) {\n    if (child === child2) {\n      return;\n    }\n\n    var index1 = this.getChildIndex(child);\n    var index2 = this.getChildIndex(child2);\n    this.children[index1] = child2;\n    this.children[index2] = child;\n    this.onChildrenChange(index1 < index2 ? index1 : index2);\n  };\n  /**\n   * Returns the index position of a child DisplayObject instance\n   *\n   * @param {PIXI.DisplayObject} child - The DisplayObject instance to identify\n   * @return {number} The index position of the child display object to identify\n   */\n\n\n  Container.prototype.getChildIndex = function getChildIndex(child) {\n    var index = this.children.indexOf(child);\n\n    if (index === -1) {\n      throw new Error('The supplied DisplayObject must be a child of the caller');\n    }\n\n    return index;\n  };\n  /**\n   * Changes the position of an existing child in the display object container\n   *\n   * @param {PIXI.DisplayObject} child - The child DisplayObject instance for which you want to change the index number\n   * @param {number} index - The resulting index number for the child display object\n   */\n\n\n  Container.prototype.setChildIndex = function setChildIndex(child, index) {\n    if (index < 0 || index >= this.children.length) {\n      throw new Error('The supplied index is out of bounds');\n    }\n\n    var currentIndex = this.getChildIndex(child);\n    (0, _utils.removeItems)(this.children, currentIndex, 1); // remove from old position\n\n    this.children.splice(index, 0, child); // add at new position\n\n    this.onChildrenChange(index);\n  };\n  /**\n   * Returns the child at the specified index\n   *\n   * @param {number} index - The index to get the child at\n   * @return {PIXI.DisplayObject} The child at the given index, if any.\n   */\n\n\n  Container.prototype.getChildAt = function getChildAt(index) {\n    if (index < 0 || index >= this.children.length) {\n      throw new Error('getChildAt: Index (' + index + ') does not exist.');\n    }\n\n    return this.children[index];\n  };\n  /**\n   * Removes one or more children from the container.\n   *\n   * @param {...PIXI.DisplayObject} child - The DisplayObject(s) to remove\n   * @return {PIXI.DisplayObject} The first child that was removed.\n   */\n\n\n  Container.prototype.removeChild = function removeChild(child) {\n    var argumentsLength = arguments.length; // if there is only one argument we can bypass looping through the them\n\n    if (argumentsLength > 1) {\n      // loop through the arguments property and add all children\n      // use it the right way (.length and [i]) so that this function can still be optimised by JS runtimes\n      for (var i = 0; i < argumentsLength; i++) {\n        this.removeChild(arguments[i]);\n      }\n    } else {\n      var index = this.children.indexOf(child);\n      if (index === -1) return null;\n      child.parent = null; // ensure child transform will be recalculated\n\n      child.transform._parentID = -1;\n      (0, _utils.removeItems)(this.children, index, 1); // ensure bounds will be recalculated\n\n      this._boundsID++; // TODO - lets either do all callbacks or all events.. not both!\n\n      this.onChildrenChange(index);\n      child.emit('removed', this);\n    }\n\n    return child;\n  };\n  /**\n   * Removes a child from the specified index position.\n   *\n   * @param {number} index - The index to get the child from\n   * @return {PIXI.DisplayObject} The child that was removed.\n   */\n\n\n  Container.prototype.removeChildAt = function removeChildAt(index) {\n    var child = this.getChildAt(index); // ensure child transform will be recalculated..\n\n    child.parent = null;\n    child.transform._parentID = -1;\n    (0, _utils.removeItems)(this.children, index, 1); // ensure bounds will be recalculated\n\n    this._boundsID++; // TODO - lets either do all callbacks or all events.. not both!\n\n    this.onChildrenChange(index);\n    child.emit('removed', this);\n    return child;\n  };\n  /**\n   * Removes all children from this container that are within the begin and end indexes.\n   *\n   * @param {number} [beginIndex=0] - The beginning position.\n   * @param {number} [endIndex=this.children.length] - The ending position. Default value is size of the container.\n   * @returns {DisplayObject[]} List of removed children\n   */\n\n\n  Container.prototype.removeChildren = function removeChildren() {\n    var beginIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var endIndex = arguments[1];\n    var begin = beginIndex;\n    var end = typeof endIndex === 'number' ? endIndex : this.children.length;\n    var range = end - begin;\n    var removed = void 0;\n\n    if (range > 0 && range <= end) {\n      removed = this.children.splice(begin, range);\n\n      for (var i = 0; i < removed.length; ++i) {\n        removed[i].parent = null;\n\n        if (removed[i].transform) {\n          removed[i].transform._parentID = -1;\n        }\n      }\n\n      this._boundsID++;\n      this.onChildrenChange(beginIndex);\n\n      for (var _i = 0; _i < removed.length; ++_i) {\n        removed[_i].emit('removed', this);\n      }\n\n      return removed;\n    } else if (range === 0 && this.children.length === 0) {\n      return [];\n    }\n\n    throw new RangeError('removeChildren: numeric values are outside the acceptable range.');\n  };\n  /**\n   * Updates the transform on all children of this container for rendering\n   */\n\n\n  Container.prototype.updateTransform = function updateTransform() {\n    this._boundsID++;\n    this.transform.updateTransform(this.parent.transform); // TODO: check render flags, how to process stuff here\n\n    this.worldAlpha = this.alpha * this.parent.worldAlpha;\n\n    for (var i = 0, j = this.children.length; i < j; ++i) {\n      var child = this.children[i];\n\n      if (child.visible) {\n        child.updateTransform();\n      }\n    }\n  };\n  /**\n   * Recalculates the bounds of the container.\n   *\n   */\n\n\n  Container.prototype.calculateBounds = function calculateBounds() {\n    this._bounds.clear();\n\n    this._calculateBounds();\n\n    for (var i = 0; i < this.children.length; i++) {\n      var child = this.children[i];\n\n      if (!child.visible || !child.renderable) {\n        continue;\n      }\n\n      child.calculateBounds(); // TODO: filter+mask, need to mask both somehow\n\n      if (child._mask) {\n        child._mask.calculateBounds();\n\n        this._bounds.addBoundsMask(child._bounds, child._mask._bounds);\n      } else if (child.filterArea) {\n        this._bounds.addBoundsArea(child._bounds, child.filterArea);\n      } else {\n        this._bounds.addBounds(child._bounds);\n      }\n    }\n\n    this._lastBoundsID = this._boundsID;\n  };\n  /**\n   * Recalculates the bounds of the object. Override this to\n   * calculate the bounds of the specific object (not including children).\n   *\n   */\n\n\n  Container.prototype._calculateBounds = function _calculateBounds() {} // FILL IN//\n\n  /**\n   * Renders the object using the WebGL renderer\n   *\n   * @param {PIXI.WebGLRenderer} renderer - The renderer\n   */\n  ;\n\n  Container.prototype.renderWebGL = function renderWebGL(renderer) {\n    // if the object is not visible or the alpha is 0 then no need to render this element\n    if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {\n      return;\n    } // do a quick check to see if this element has a mask or a filter.\n\n\n    if (this._mask || this._filters) {\n      this.renderAdvancedWebGL(renderer);\n    } else {\n      this._renderWebGL(renderer); // simple render children!\n\n\n      for (var i = 0, j = this.children.length; i < j; ++i) {\n        this.children[i].renderWebGL(renderer);\n      }\n    }\n  };\n  /**\n   * Render the object using the WebGL renderer and advanced features.\n   *\n   * @private\n   * @param {PIXI.WebGLRenderer} renderer - The renderer\n   */\n\n\n  Container.prototype.renderAdvancedWebGL = function renderAdvancedWebGL(renderer) {\n    renderer.flush();\n    var filters = this._filters;\n    var mask = this._mask; // push filter first as we need to ensure the stencil buffer is correct for any masking\n\n    if (filters) {\n      if (!this._enabledFilters) {\n        this._enabledFilters = [];\n      }\n\n      this._enabledFilters.length = 0;\n\n      for (var i = 0; i < filters.length; i++) {\n        if (filters[i].enabled) {\n          this._enabledFilters.push(filters[i]);\n        }\n      }\n\n      if (this._enabledFilters.length) {\n        renderer.filterManager.pushFilter(this, this._enabledFilters);\n      }\n    }\n\n    if (mask) {\n      renderer.maskManager.pushMask(this, this._mask);\n    } // add this object to the batch, only rendered if it has a texture.\n\n\n    this._renderWebGL(renderer); // now loop through the children and make sure they get rendered\n\n\n    for (var _i2 = 0, j = this.children.length; _i2 < j; _i2++) {\n      this.children[_i2].renderWebGL(renderer);\n    }\n\n    renderer.flush();\n\n    if (mask) {\n      renderer.maskManager.popMask(this, this._mask);\n    }\n\n    if (filters && this._enabledFilters && this._enabledFilters.length) {\n      renderer.filterManager.popFilter();\n    }\n  };\n  /**\n   * To be overridden by the subclasses.\n   *\n   * @private\n   * @param {PIXI.WebGLRenderer} renderer - The renderer\n   */\n\n\n  Container.prototype._renderWebGL = function _renderWebGL(renderer) // eslint-disable-line no-unused-vars\n  {} // this is where content itself gets rendered...\n\n  /**\n   * To be overridden by the subclass\n   *\n   * @private\n   * @param {PIXI.CanvasRenderer} renderer - The renderer\n   */\n  ;\n\n  Container.prototype._renderCanvas = function _renderCanvas(renderer) // eslint-disable-line no-unused-vars\n  {} // this is where content itself gets rendered...\n\n  /**\n   * Renders the object using the Canvas renderer\n   *\n   * @param {PIXI.CanvasRenderer} renderer - The renderer\n   */\n  ;\n\n  Container.prototype.renderCanvas = function renderCanvas(renderer) {\n    // if not visible or the alpha is 0 then no need to render this\n    if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {\n      return;\n    }\n\n    if (this._mask) {\n      renderer.maskManager.pushMask(this._mask);\n    }\n\n    this._renderCanvas(renderer);\n\n    for (var i = 0, j = this.children.length; i < j; ++i) {\n      this.children[i].renderCanvas(renderer);\n    }\n\n    if (this._mask) {\n      renderer.maskManager.popMask(renderer);\n    }\n  };\n  /**\n   * Removes all internal references and listeners as well as removes children from the display list.\n   * Do not use a Container after calling `destroy`.\n   *\n   * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy\n   *  method called as well. 'options' will be passed on to those calls.\n   * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true\n   *  Should it destroy the texture of the child sprite\n   * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true\n   *  Should it destroy the base texture of the child sprite\n   */\n\n\n  Container.prototype.destroy = function destroy(options) {\n    _DisplayObject.prototype.destroy.call(this);\n\n    var destroyChildren = typeof options === 'boolean' ? options : options && options.children;\n    var oldChildren = this.removeChildren(0, this.children.length);\n\n    if (destroyChildren) {\n      for (var i = 0; i < oldChildren.length; ++i) {\n        oldChildren[i].destroy(options);\n      }\n    }\n  };\n  /**\n   * The width of the Container, setting this will actually modify the scale to achieve the value set\n   *\n   * @member {number}\n   */\n\n\n  _createClass(Container, [{\n    key: 'width',\n    get: function get() {\n      return this.scale.x * this.getLocalBounds().width;\n    },\n    set: function set(value) // eslint-disable-line require-jsdoc\n    {\n      var width = this.getLocalBounds().width;\n\n      if (width !== 0) {\n        this.scale.x = value / width;\n      } else {\n        this.scale.x = 1;\n      }\n\n      this._width = value;\n    }\n    /**\n     * The height of the Container, setting this will actually modify the scale to achieve the value set\n     *\n     * @member {number}\n     */\n\n  }, {\n    key: 'height',\n    get: function get() {\n      return this.scale.y * this.getLocalBounds().height;\n    },\n    set: function set(value) // eslint-disable-line require-jsdoc\n    {\n      var height = this.getLocalBounds().height;\n\n      if (height !== 0) {\n        this.scale.y = value / height;\n      } else {\n        this.scale.y = 1;\n      }\n\n      this._height = value;\n    }\n  }]);\n\n  return Container;\n}(_DisplayObject3.default); // performance increase to avoid using call.. (10x faster)\n\n\nexports.default = Container;\nContainer.prototype.containerUpdateTransform = Container.prototype.updateTransform;","map":null,"metadata":{},"sourceType":"script"}