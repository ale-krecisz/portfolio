{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _core = require('../core');\n\nvar core = _interopRequireWildcard(_core);\n\nvar _CanvasTinter = require('../core/sprites/canvas/CanvasTinter');\n\nvar _CanvasTinter2 = _interopRequireDefault(_CanvasTinter);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar tempPoint = new core.Point();\n/**\n * A tiling sprite is a fast way of rendering a tiling image\n *\n * @class\n * @extends PIXI.Sprite\n * @memberof PIXI.extras\n */\n\nvar TilingSprite = function (_core$Sprite) {\n  _inherits(TilingSprite, _core$Sprite);\n  /**\n   * @param {PIXI.Texture} texture - the texture of the tiling sprite\n   * @param {number} [width=100] - the width of the tiling sprite\n   * @param {number} [height=100] - the height of the tiling sprite\n   */\n\n\n  function TilingSprite(texture) {\n    var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n    var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 100;\n\n    _classCallCheck(this, TilingSprite);\n    /**\n     * Tile transform\n     *\n     * @member {PIXI.TransformStatic}\n     */\n\n\n    var _this = _possibleConstructorReturn(this, _core$Sprite.call(this, texture));\n\n    _this.tileTransform = new core.TransformStatic(); // /// private\n\n    /**\n     * The with of the tiling sprite\n     *\n     * @member {number}\n     * @private\n     */\n\n    _this._width = width;\n    /**\n     * The height of the tiling sprite\n     *\n     * @member {number}\n     * @private\n     */\n\n    _this._height = height;\n    /**\n     * Canvas pattern\n     *\n     * @type {CanvasPattern}\n     * @private\n     */\n\n    _this._canvasPattern = null;\n    /**\n     * transform that is applied to UV to get the texture coords\n     *\n     * @member {PIXI.TextureMatrix}\n     */\n\n    _this.uvTransform = texture.transform || new core.TextureMatrix(texture);\n    /**\n     * Plugin that is responsible for rendering this element.\n     * Allows to customize the rendering process without overriding '_renderWebGL' method.\n     *\n     * @member {string}\n     * @default 'tilingSprite'\n     */\n\n    _this.pluginName = 'tilingSprite';\n    /**\n     * Whether or not anchor affects uvs\n     *\n     * @member {boolean}\n     * @default false\n     */\n\n    _this.uvRespectAnchor = false;\n    return _this;\n  }\n  /**\n   * Changes frame clamping in corresponding textureTransform, shortcut\n   * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas\n   *\n   * @default 0.5\n   * @member {number}\n   */\n\n  /**\n   * @private\n   */\n\n\n  TilingSprite.prototype._onTextureUpdate = function _onTextureUpdate() {\n    if (this.uvTransform) {\n      this.uvTransform.texture = this._texture;\n    }\n\n    this.cachedTint = 0xFFFFFF;\n  };\n  /**\n   * Renders the object using the WebGL renderer\n   *\n   * @private\n   * @param {PIXI.WebGLRenderer} renderer - The renderer\n   */\n\n\n  TilingSprite.prototype._renderWebGL = function _renderWebGL(renderer) {\n    // tweak our texture temporarily..\n    var texture = this._texture;\n\n    if (!texture || !texture.valid) {\n      return;\n    }\n\n    this.tileTransform.updateLocalTransform();\n    this.uvTransform.update();\n    renderer.setObjectRenderer(renderer.plugins[this.pluginName]);\n    renderer.plugins[this.pluginName].render(this);\n  };\n  /**\n   * Renders the object using the Canvas renderer\n   *\n   * @private\n   * @param {PIXI.CanvasRenderer} renderer - a reference to the canvas renderer\n   */\n\n\n  TilingSprite.prototype._renderCanvas = function _renderCanvas(renderer) {\n    var texture = this._texture;\n\n    if (!texture.baseTexture.hasLoaded) {\n      return;\n    }\n\n    var context = renderer.context;\n    var transform = this.worldTransform;\n    var resolution = renderer.resolution;\n    var isTextureRotated = texture.rotate === 2;\n    var baseTexture = texture.baseTexture;\n    var baseTextureResolution = baseTexture.resolution;\n    var modX = this.tilePosition.x / this.tileScale.x % texture.orig.width * baseTextureResolution;\n    var modY = this.tilePosition.y / this.tileScale.y % texture.orig.height * baseTextureResolution; // create a nice shiny pattern!\n\n    if (this._textureID !== this._texture._updateID || this.cachedTint !== this.tint) {\n      this._textureID = this._texture._updateID; // cut an object from a spritesheet..\n\n      var tempCanvas = new core.CanvasRenderTarget(texture.orig.width, texture.orig.height, baseTextureResolution); // Tint the tiling sprite\n\n      if (this.tint !== 0xFFFFFF) {\n        this.tintedTexture = _CanvasTinter2.default.getTintedTexture(this, this.tint);\n        tempCanvas.context.drawImage(this.tintedTexture, 0, 0);\n      } else {\n        var sx = texture._frame.x * baseTextureResolution;\n        var sy = texture._frame.y * baseTextureResolution;\n        var sWidth = texture._frame.width * baseTextureResolution;\n        var sHeight = texture._frame.height * baseTextureResolution;\n        var dWidth = (texture.trim ? texture.trim.width : texture.orig.width) * baseTextureResolution;\n        var dHeight = (texture.trim ? texture.trim.height : texture.orig.height) * baseTextureResolution;\n        var dx = (texture.trim ? texture.trim.x : 0) * baseTextureResolution;\n        var dy = (texture.trim ? texture.trim.y : 0) * baseTextureResolution;\n\n        if (isTextureRotated) {\n          // Apply rotation and transform\n          tempCanvas.context.rotate(-Math.PI / 2);\n          tempCanvas.context.translate(-dHeight, 0);\n          tempCanvas.context.drawImage(baseTexture.source, sx, sy, sWidth, sHeight, -dy, dx, dHeight, dWidth);\n        } else {\n          tempCanvas.context.drawImage(baseTexture.source, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);\n        }\n      }\n\n      this.cachedTint = this.tint;\n      this._canvasPattern = tempCanvas.context.createPattern(tempCanvas.canvas, 'repeat');\n    } // set context state..\n\n\n    context.globalAlpha = this.worldAlpha;\n    context.setTransform(transform.a * resolution, transform.b * resolution, transform.c * resolution, transform.d * resolution, transform.tx * resolution, transform.ty * resolution);\n    renderer.setBlendMode(this.blendMode); // fill the pattern!\n\n    context.fillStyle = this._canvasPattern; // TODO - this should be rolled into the setTransform above..\n\n    context.scale(this.tileScale.x / baseTextureResolution, this.tileScale.y / baseTextureResolution);\n    var anchorX = this.anchor.x * -this._width * baseTextureResolution;\n    var anchorY = this.anchor.y * -this._height * baseTextureResolution;\n\n    if (this.uvRespectAnchor) {\n      context.translate(modX, modY);\n      context.fillRect(-modX + anchorX, -modY + anchorY, this._width / this.tileScale.x * baseTextureResolution, this._height / this.tileScale.y * baseTextureResolution);\n    } else {\n      context.translate(modX + anchorX, modY + anchorY);\n      context.fillRect(-modX, -modY, this._width / this.tileScale.x * baseTextureResolution, this._height / this.tileScale.y * baseTextureResolution);\n    }\n  };\n  /**\n   * Updates the bounds of the tiling sprite.\n   *\n   * @private\n   */\n\n\n  TilingSprite.prototype._calculateBounds = function _calculateBounds() {\n    var minX = this._width * -this._anchor._x;\n    var minY = this._height * -this._anchor._y;\n    var maxX = this._width * (1 - this._anchor._x);\n    var maxY = this._height * (1 - this._anchor._y);\n\n    this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);\n  };\n  /**\n   * Gets the local bounds of the sprite object.\n   *\n   * @param {PIXI.Rectangle} rect - The output rectangle.\n   * @return {PIXI.Rectangle} The bounds.\n   */\n\n\n  TilingSprite.prototype.getLocalBounds = function getLocalBounds(rect) {\n    // we can do a fast local bounds if the sprite has no children!\n    if (this.children.length === 0) {\n      this._bounds.minX = this._width * -this._anchor._x;\n      this._bounds.minY = this._height * -this._anchor._y;\n      this._bounds.maxX = this._width * (1 - this._anchor._x);\n      this._bounds.maxY = this._height * (1 - this._anchor._y);\n\n      if (!rect) {\n        if (!this._localBoundsRect) {\n          this._localBoundsRect = new core.Rectangle();\n        }\n\n        rect = this._localBoundsRect;\n      }\n\n      return this._bounds.getRectangle(rect);\n    }\n\n    return _core$Sprite.prototype.getLocalBounds.call(this, rect);\n  };\n  /**\n   * Checks if a point is inside this tiling sprite.\n   *\n   * @param {PIXI.Point} point - the point to check\n   * @return {boolean} Whether or not the sprite contains the point.\n   */\n\n\n  TilingSprite.prototype.containsPoint = function containsPoint(point) {\n    this.worldTransform.applyInverse(point, tempPoint);\n    var width = this._width;\n    var height = this._height;\n    var x1 = -width * this.anchor._x;\n\n    if (tempPoint.x >= x1 && tempPoint.x < x1 + width) {\n      var y1 = -height * this.anchor._y;\n\n      if (tempPoint.y >= y1 && tempPoint.y < y1 + height) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\n   * Destroys this sprite and optionally its texture and children\n   *\n   * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy\n   *      method called as well. 'options' will be passed on to those calls.\n   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the sprite as well\n   * @param {boolean} [options.baseTexture=false] - Should it destroy the base texture of the sprite as well\n   */\n\n\n  TilingSprite.prototype.destroy = function destroy(options) {\n    _core$Sprite.prototype.destroy.call(this, options);\n\n    this.tileTransform = null;\n    this.uvTransform = null;\n  };\n  /**\n   * Helper function that creates a new tiling sprite based on the source you provide.\n   * The source can be - frame id, image url, video url, canvas element, video element, base texture\n   *\n   * @static\n   * @param {number|string|PIXI.BaseTexture|HTMLCanvasElement|HTMLVideoElement} source - Source to create texture from\n   * @param {number} width - the width of the tiling sprite\n   * @param {number} height - the height of the tiling sprite\n   * @return {PIXI.Texture} The newly created texture\n   */\n\n\n  TilingSprite.from = function from(source, width, height) {\n    return new TilingSprite(core.Texture.from(source), width, height);\n  };\n  /**\n   * Helper function that creates a tiling sprite that will use a texture from the TextureCache based on the frameId\n   * The frame ids are created when a Texture packer file has been loaded\n   *\n   * @static\n   * @param {string} frameId - The frame Id of the texture in the cache\n   * @param {number} width - the width of the tiling sprite\n   * @param {number} height - the height of the tiling sprite\n   * @return {PIXI.extras.TilingSprite} A new TilingSprite using a texture from the texture cache matching the frameId\n   */\n\n\n  TilingSprite.fromFrame = function fromFrame(frameId, width, height) {\n    var texture = core.utils.TextureCache[frameId];\n\n    if (!texture) {\n      throw new Error('The frameId \"' + frameId + '\" does not exist in the texture cache ' + this);\n    }\n\n    return new TilingSprite(texture, width, height);\n  };\n  /**\n   * Helper function that creates a sprite that will contain a texture based on an image url\n   * If the image is not in the texture cache it will be loaded\n   *\n   * @static\n   * @param {string} imageId - The image url of the texture\n   * @param {number} width - the width of the tiling sprite\n   * @param {number} height - the height of the tiling sprite\n   * @param {boolean} [crossorigin] - if you want to specify the cross-origin parameter\n   * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - if you want to specify the scale mode,\n   *  see {@link PIXI.SCALE_MODES} for possible values\n   * @return {PIXI.extras.TilingSprite} A new TilingSprite using a texture from the texture cache matching the image id\n   */\n\n\n  TilingSprite.fromImage = function fromImage(imageId, width, height, crossorigin, scaleMode) {\n    return new TilingSprite(core.Texture.fromImage(imageId, crossorigin, scaleMode), width, height);\n  };\n  /**\n   * The width of the sprite, setting this will actually modify the scale to achieve the value set\n   *\n   * @member {number}\n   */\n\n\n  _createClass(TilingSprite, [{\n    key: 'clampMargin',\n    get: function get() {\n      return this.uvTransform.clampMargin;\n    },\n    set: function set(value) // eslint-disable-line require-jsdoc\n    {\n      this.uvTransform.clampMargin = value;\n      this.uvTransform.update(true);\n    }\n    /**\n     * The scaling of the image that is being tiled\n     *\n     * @member {PIXI.ObservablePoint}\n     */\n\n  }, {\n    key: 'tileScale',\n    get: function get() {\n      return this.tileTransform.scale;\n    },\n    set: function set(value) // eslint-disable-line require-jsdoc\n    {\n      this.tileTransform.scale.copy(value);\n    }\n    /**\n     * The offset of the image that is being tiled\n     *\n     * @member {PIXI.ObservablePoint}\n     */\n\n  }, {\n    key: 'tilePosition',\n    get: function get() {\n      return this.tileTransform.position;\n    },\n    set: function set(value) // eslint-disable-line require-jsdoc\n    {\n      this.tileTransform.position.copy(value);\n    }\n  }, {\n    key: 'width',\n    get: function get() {\n      return this._width;\n    },\n    set: function set(value) // eslint-disable-line require-jsdoc\n    {\n      this._width = value;\n    }\n    /**\n     * The height of the TilingSprite, setting this will actually modify the scale to achieve the value set\n     *\n     * @member {number}\n     */\n\n  }, {\n    key: 'height',\n    get: function get() {\n      return this._height;\n    },\n    set: function set(value) // eslint-disable-line require-jsdoc\n    {\n      this._height = value;\n    }\n  }]);\n\n  return TilingSprite;\n}(core.Sprite);\n\nexports.default = TilingSprite;","map":null,"metadata":{},"sourceType":"script"}